<html>
  <head>
    <title>ggg</title>
    <style>
      body {
        background-color: grey;
      }
      #canvas {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translateX(-50%) translateY(-50%);
      }
  </style>
  </head>
  <body>

    <img src="trace.png">
    <img src="trace-2.png">

    <script src="pixi.js"></script>
    <script src="curves.js"></script>
    <script src="perlin.js"></script>
    <script src="numbers.js"></script>

    <script>      
      let app = new PIXI.Application({ 
        width: 500, 
        height: 350,
        antialias: true, 
        resolution: 1,
        forceCanvas: false,
        roundPixels: true,
        preserveDrawingBuffer: true,
      });
      document.body.appendChild(app.view);

      let bk = new PIXI.Graphics();
      bk.beginFill(0xffffff);
      bk.drawRect(0, 0, 500, 500);
      bk.endFill();

      let counter = 0;

      app.stage.addChild(bk)

      var container = new PIXI.ParticleContainer(500000);
      app.stage.addChild(container)

      var template = new PIXI.Graphics();
      template.beginFill(0xaa0000);
      template.drawCircle(0, 0, 0.5);
      template.endFill();
      var texture = app.renderer.generateTexture(template);
      var circle = new PIXI.Sprite(texture);

      app.stage.addChild(template);

      var containerTwo = new PIXI.ParticleContainer(500000);
      app.stage.addChild(containerTwo)
      containerTwo.blendMode = PIXI.BLEND_MODES.MULTIPLY

      var width = 0
      var endWidth = 500

      var bezier = [{x: 150, y: 150}, {x: 0, y: 0}, {x: 100, y:-100}, {x:470, y:470}]
    
      var bezierPoints = findCBezPoints(bezier);
    
      var points = [null, null, null];
    
      var widthFactor = (width - endWidth) / bezierPoints.length
      
      var iterations = 200
    
      for (var j=0; j<iterations; j++ ) {
    
        for(var i=0; i<bezierPoints.length; i++) {
          
          var drawWidth = width - (widthFactor * i)

          var x = bezierPoints[i].x;
          var y = bezierPoints[i].y;
    
          points[0] = points[1];
          points[1] = points[2];
          points[2] = { X:x, Y:y};
    
          if(points[0] == null)
              continue;
    
          var p0 = points[0];
          var p1 = points[1];
          var p2 = points[2];
    
          var x0 = (p0.X + p1.X) / 2;
          var y0 = (p0.Y + p1.Y) / 2;
          
          var alpha = perlin.get(x0, y0)
          
          if(alpha < 0.1) {
            alpha = 0.1
          }

          alpha = 1
    
          
          var radius = drawWidth
    
          if(width == 1) {
            radius = radius / 20
          }
    
          var offsetX = rand(-radius, radius);
          var offsetY = rand(-radius, radius);

          if(j > iterations*0.70) {
            offsetY = -drawWidth
          } 
          if (j > iterations*0.85) {
            offsetY = drawWidth
          }
          
          let circleRadius = radius * Math.sqrt(Math.random())
          let theta = Math.random() * 2 * Math.PI

          x0 = x0 + radius * Math.cos(theta)
          y0 = y0 + radius * Math.sin(theta)

          if(i < bezierPoints.length*0.2) {
            alpha = 0 
          }

          counter++;


          if(i > 1) {
            let duplicate = new PIXI.Sprite(circle.texture);
            duplicate.x = x0
            duplicate.y = y0
            duplicate.alpha = alpha
            //duplicate.blendMode = PIXI.BLEND_MODES.COLOR_BURN
            container.addChild(duplicate)
          
          }
  
    
        }
    
      }

      


      var template = new PIXI.Graphics();
      template.beginFill(0xff0000);
      template.drawRect(0, 0, 1, 1);
      template.endFill();
      
      var texture = app.renderer.generateTexture(template);
      var circle = new PIXI.Sprite(texture);

      app.stage.addChild(template);

      var width = 0
      var endWidth = 50

      var bezier = [{x: 150, y: 150}, {x: 0, y: 0}, {x: 100, y:-100}, {x:450, y:450}]
    
      var bezierPoints = findCBezPoints(bezier);
    
      var points = [null, null, null];
    
      var widthFactor = (width - endWidth) / bezierPoints.length
      
      var iterations = 50
    
      for (var j=0; j<iterations; j++ ) {
    
        for(var i=0; i<bezierPoints.length; i++) {
          
          var drawWidth = width - (widthFactor * i)

          var x = bezierPoints[i].x;
          var y = bezierPoints[i].y;
    
          points[0] = points[1];
          points[1] = points[2];
          points[2] = { X:x, Y:y};
    
          if(points[0] == null)
              continue;
    
          var p0 = points[0];
          var p1 = points[1];
          var p2 = points[2];
    
          var x0 = (p0.X + p1.X) / 2;
          var y0 = (p0.Y + p1.Y) / 2;
          
          var alpha = perlin.get(x0, y0)
          
          if(alpha < 0.1) {
            alpha = 0.1
          }

          alpha = 1
    
          if(i > bezierPoints.length*0.8) {
            let fader = (drawWidth/i)*10
            //alpha = alpha - fader
          }

          var radius = drawWidth
    
          if(width == 1) {
            radius = radius / 20
          }
    
          var offsetX = rand(-radius, radius);
          var offsetY = rand(-radius, radius);

          if(j > iterations*0.70) {
            offsetY = -drawWidth
          } 
          if (j > iterations*0.85) {
            offsetY = drawWidth
          }
          
          let circleRadius = radius * Math.sqrt(Math.random())
          let theta = Math.random() * 2 * Math.PI

          x0 = x0 + radius * Math.cos(theta)
          y0 = y0 + radius * Math.sin(theta)

          counter++;

          if(i > 1) {
            let duplicate = new PIXI.Sprite(circle.texture);
            duplicate.x = x0
            duplicate.y = y0
            duplicate.alpha = alpha
            //duplicate.blendMode = PIXI.BLEND_MODES.MULTIPLY
            containerTwo.addChild(duplicate)
          
          }
  
    
        }
    
      }

      






      var template = new PIXI.Graphics();
      template.beginFill(0x00ff00);
      template.drawRect(0, 0, 1, 1);
      template.endFill();

      var texture = app.renderer.generateTexture(template);
      var circle = new PIXI.Sprite(texture);

      app.stage.addChild(template);


      var width = 0
      var endWidth = 10

      var bezier = [{x: 450, y: 150}, {x: 450, y: 130}, {x: 100, y:-100}, {x:100, y:450}]
    
      var bezierPoints = findCBezPoints(bezier);
    
      var points = [null, null, null];
    
      var widthFactor = (width - endWidth) / bezierPoints.length
      
      var iterations = 200
    
      for (var j=0; j<iterations; j++ ) {
    
        for(var i=0; i<bezierPoints.length; i++) {
          
          var drawWidth = width - (widthFactor * i)

          var x = bezierPoints[i].x;
          var y = bezierPoints[i].y;
    
          points[0] = points[1];
          points[1] = points[2];
          points[2] = { X:x, Y:y};
    
          if(points[0] == null)
              continue;
    
          var p0 = points[0];
          var p1 = points[1];
          var p2 = points[2];
    
          var x0 = (p0.X + p1.X) / 2;
          var y0 = (p0.Y + p1.Y) / 2;
          
          var alpha = 0
          //alpha = perlin.get(x0, y0)
          
          if(alpha < 0.1) {
            alpha = 0.1
          }

          //alpha = 1
    
          if(i > bezierPoints.length*0.8) {
            let fader = (drawWidth/i)*10
            //alpha = alpha - fader
          }

          var radius = drawWidth
    
          if(width == 1) {
            radius = radius / 20
          }
    
          var offsetX = rand(-radius, radius);
          var offsetY = rand(-radius, radius);

          if(j > iterations*0.70) {
            offsetY = -drawWidth
          } 
          if (j > iterations*0.85) {
            offsetY = drawWidth
          }
          
          let circleRadius = radius * Math.sqrt(Math.random())
          let theta = Math.random() * 2 * Math.PI

          x0 = x0 + radius * Math.cos(theta)
          y0 = y0 + radius * Math.sin(theta)

          counter++;

          if(i > 1) {
            let duplicate = new PIXI.Sprite(circle.texture);
            duplicate.x = x0
            duplicate.y = y0
            duplicate.alpha = alpha
            //duplicate.blendMode = PIXI.BLEND_MODES.MULTIPLY
            container.addChild(duplicate)
          
          }
  
    
        }
    
      }

      console.log(counter)

      
      </script>
  </body>
</html>




