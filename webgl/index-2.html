<html>

<head>
    <title>ggg</title>
    <style>
        body {
            background-color: grey;
        }
        
        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-50%);
        }
    </style>
</head>

<body>

    <img src="trace.png">
    <img src="trace-2.png">

    <script src="pixi.js"></script>
    <script src="curves.js"></script>
    <script src="perlin.js"></script>
    <script src="numbers.js"></script>
    <script src="chroma.js"></script>

    <script>
        let app = new PIXI.Application({
            width: 350,
            height: 350,
            antialias: true,
            resolution: 1,
            forceCanvas: false,
            roundPixels: true,
        });
        document.body.appendChild(app.view);



        var counter = 0
        var counter2 = 0

        let randomColor = rand(0, 360);

        let hairColor = chroma(randomColor, 0.8, 0.5, 'hsl');
        let highlightColor = chroma(randomColor + 230, 0.8, 0.6, 'hsl');
        var multiplyColor = chroma.blend(hairColor, highlightColor, 'multiply');
        


        //var eyebrowColor = chroma.blend(hairColor, highlightColor, 'multiply');

        //console.log(hairColor.hex(), highlightColor.hex(), multiplyColor.hex());
        //var multiplyColor = chroma.blend(hairColor, highlightColor, 'burn');
        //var multiplyColor = chroma.blend(hairColor, highlightColor, 'overlay');

        hairColors = multiplyColor
        hairColorsDark = chroma.scale([hairColors, 'black']).colors(4);
        hairColorsLight = chroma.scale([hairColors, 'white']).colors(5);
        hairColorsLightTwo = chroma.scale([hairColors, 'white']).colors(30);
        let backgroundColor = hairColorsLightTwo[27];
        backgroundColor = PIXI.utils.string2hex(backgroundColor)


        let bk = new PIXI.Graphics();
        bk.beginFill(backgroundColor);
        bk.drawRect(0, 0, 500, 500);
        bk.endFill();
        app.stage.addChild(bk)

        let color1 = new PIXI.Graphics();
        hairColor = PIXI.utils.string2hex(hairColor.hex())
        color1.beginFill(hairColor);
        color1.drawRect(0, 0, 10, 10);
        color1.endFill();
        app.stage.addChild(color1);

        let color2 = new PIXI.Graphics();
        highlightColor = PIXI.utils.string2hex(highlightColor.hex())
        color2.beginFill(highlightColor);
        color2.drawRect(10, 0, 10, 10);
        color2.endFill();
        app.stage.addChild(color2);

        let color3 = new PIXI.Graphics();
        multiplyColor = PIXI.utils.string2hex(multiplyColor.hex())
        color3.beginFill(multiplyColor);
        color3.drawRect(20, 0, 10, 10);
        color3.endFill();
        app.stage.addChild(color3);

        var eyeContainer = new PIXI.Container();
        var container = new PIXI.ParticleContainer(500000);


        let hairColor1 = PIXI.utils.string2hex(hairColorsDark[3])
        let hairColor2 = PIXI.utils.string2hex(hairColorsDark[2])
        let hairColor3 = PIXI.utils.string2hex(hairColorsDark[1])
        let hairColor4 = PIXI.utils.string2hex(hairColorsDark[0])
        let hairColor5 = PIXI.utils.string2hex(hairColorsLight[1])


        let startColor = chroma(randomColor, 0.3, 0.5, 'hsl');
        let endColor = chroma(randomColor + 115, 0.5, 0.6, 'hsl');
        startColor = chroma(startColor).hex()
        endColor = chroma(endColor).hex()
        startColor = PIXI.utils.string2hex(startColor)
        endColor = PIXI.utils.string2hex(endColor)


        

        

        //Draw Eye

        var findBezierPoint = function(t, p0, p1, p2, p3) {
            var t2 = t * t;
            var t3 = t2 * t;
            return (p0 * (t3 * 6) + p1 * (t2 * 3) + p2 * 3 + p3) / 6;
        };

        
        class pencilLine {
            constructor({startWidth=1,endWidth=2,iterations=3,color=4} = {}) {
                this.startWidth = startWidth;
                this.endWidth = endWidth;
                this.iterations = 1;
                this.color = '#000000';
            }
        }

        var eyeBrow = new pencilLine({
            startWidth:1,
            endWidth:1
        })

        console.log(eyeBrow)



        
        
        var pencilTo = function(width, endWidth, iterations, color, startX, startY, endX, endY, cp1, cp2, cp3, cp4, circle, size) {
          
          color = PIXI.utils.string2hex(color)

          let center = 500/2
  
          let pointArray = [[center,center]]

          let newEndX = startX + endX
          let newEndY = startY + endY
        
          let cp1Local = startX + cp1
          let cp2Local = startY + cp2
        
          let cp3Local = startX + cp3
          let cp4Local = startY + cp4
        
          var bezier = [{x: startX, y: startY}, {x: cp1Local, y: cp2Local}, {x: cp3Local, y:cp4Local}, {x:newEndX, y:newEndY}]
        
          var bezierPoints = findCBezPoints(bezier);
        
          var points = [null, null, null];
        
          var widthFactor = (width - endWidth) / bezierPoints.length
          
          template = new PIXI.Graphics();

          pointArray.push([newEndX, newEndY])

          for (var j=0; j<iterations; j++ ) {

            var points = [null, null, null];
  
            for(var i=0; i<bezierPoints.length; i++) {

              var drawWidth = width - (widthFactor * i)

              var x = bezierPoints[i].x;
              var y = bezierPoints[i].y;
        
              points[0] = points[1];
              points[1] = points[2];
              points[2] = { X:x, Y:y};
        
              if(points[0] == null)
                  continue;
        
              var p0 = points[0];
              var p1 = points[1];
              var p2 = points[2];
        
              var x0 = (p0.X + p1.X) / 2;
              var y0 = (p0.Y + p1.Y) / 2;
  
        //ctx.moveTo(x0, y0);
        
        var alpha = perlin.get(x0, y0)
  
        if(alpha < 0.1) {
          alpha = 0.1
        }
  
        if(i > bezierPoints.length*0.5 && drawWidth < 1) {
          let fader = (drawWidth/i)*2
          //alpha = alpha - fader
          //console.log(alpha)
        }
        
        //ctx.globalAlpha = alpha
  
        var radius = drawWidth
  
        
  
        var offsetX = rand(-radius, radius);
        var offsetY = rand(-radius, radius);
        
        var randomX = x0 + offsetX;
        var randomY = y0 + offsetY;

        randomX = x0 + radius * 2 * Math.random() - radius;
        randomY = y0 + radius * 2 * Math.random() - radius;

        // Circle Form 
        var angle = Math.random() * Math.PI * 2;
        randomX = x0 + offsetX * Math.sin(angle);
        randomY = y0 + offsetX * Math.cos(angle);

        //Ellipsis Form
        if(width == 40) {
            var firstAngle = irisSize
            var secondAngle = irisSizeY
            r = firstAngle * Math.sqrt(Math.random(0,.1))
            fi = 2 * Math.PI * Math.random(0,.1)
            randomX = x0 + r * Math.cos(fi)
            randomY = y0 + secondAngle / firstAngle *  r * Math.sin(fi)
        }

              template.beginFill(color, alpha);
              template.drawCircle(randomX, randomY, size);
              template.endFill();
  
  


            }

          }

          
          eyeContainer.addChild(template);



        }



        /*
        hairColorBrightness = chroma(hairColor).luminance()
        highlightColorBrightness = chroma(highlightColor).luminance()
        multiplyColorBrightness = chroma(multiplyColor).luminance()
        
        if(multiplyColorBrightness > 0.25) {
          multiplyColor = chroma(multiplyColor).darken(0.8)
        }

        if(hairColorBrightness < highlightColorBrightness) {
          replaceColor = highlightColor
          highlightColor = hairColor
          hairColor = replaceColor
        }

        hairColor = chroma(hairColor).hex()
        multiplyColor = chroma(multiplyColor).hex()
        highlightColor = chroma(highlightColor).hex()
        



        eyeY = rand(165, 180)
        eyeX = rand(180, 210)

        irisSize = 40
        irisSizeY = rand(35, 55)
        //Iris
        pencilTo(irisSize, irisSize, irisSize*100, hairColor, eyeX, eyeY, 0, 0, 0, -10, 0, 10, 0, 1)

        //Pupil
        pupilX = eyeX + rand(-5, 5)
        pupilY = eyeY + rand(0, 10)

        pupilSize = rand(4, 10)
        pupilShineOffsetX = rand(-20, 20)
        pupilShineOffsetY = rand(-20, 20)
        pupilShineEnd = rand(0, 10)

        eyeShineTrue = rand(0, 1)
        eyeShineTwoTrue = rand(0, 1)
        if(eyeShineTrue > 0.5) {
            pencilTo(pupilSize*2, 2, pupilSize*10, '#FFFFFF', pupilX-pupilShineOffsetX, pupilY-pupilShineOffsetY, pupilShineEnd, 0, 0, -10, 0, 10, 0, 1)
        }
        if(eyeShineTwoTrue > 0.8) {
            pencilTo(pupilSize*4, 2, pupilSize*20, '#FFFFFF', pupilX+pupilShineOffsetX, pupilY+pupilShineOffsetY, pupilShineEnd, 0, 0, -10, 0, 10, 0, 1)
        }
        pencilTo(pupilSize, 2, pupilSize*40, multiplyColor, pupilX, pupilY, 0, 0, 0, -10, 0, 10, 0, 1)
        //pencilTo(5, 2, 13, multiplyColor, 222, pupilY+2, -7, -7, 0, 0, -10, 5, 0, 1)
        //pencilTo(5, 2, 13, multiplyColor, 215, pupilY-4, 5, 5, 0, 10, 0, -10, 0, 1)
        //pencilTo(5, 2, 13, multiplyColor, 213, pupilY-3, 7, 7, 0, 10, 0, -10, 0, 1)

        //Eye Border
        //pencilTo(1, 1, 30, highlightColor, 220, 220, -45, -45, -30, 0, -40, -20, 0, 1)
        //pencilTo(1, 1, 40, highlightColor, 175, 175, 45, -38, 5, -15, 0, -30, 0, 1)

        eyeBorderThickness = rand(1, 3)
        eyeBorderIterations = eyeBorderThickness * rand(5, 10)

        //Top to Right
        pencilTo(eyeBorderThickness, eyeBorderThickness/2, eyeBorderIterations, highlightColor, eyeX, eyeY - irisSizeY, irisSize, irisSizeY, 0, 0, irisSize, 0, 0.2, 1)
        pencilTo(eyeBorderThickness/2, eyeBorderThickness/4, eyeBorderIterations, highlightColor, eyeX + irisSize, eyeY, -irisSize, irisSizeY, 0, 0, 0, irisSizeY, 0.2, 1)
        pencilTo(eyeBorderThickness/4, eyeBorderThickness/2, eyeBorderIterations, highlightColor, eyeX, eyeY + irisSizeY, -irisSize, -irisSizeY, 0, 0, -irisSize, 0, 0.2, 1)
        pencilTo(eyeBorderThickness/2, eyeBorderThickness, eyeBorderIterations, highlightColor, eyeX - irisSize, eyeY, irisSize, -irisSizeY, 0, 0, 0, -irisSizeY, 0.2, 1)
        //pencilTo(1, 1, 30, highlightColor, 260, 175, -40, 45, 0, 25, 0, 35, 0, 1)


        let square = new PIXI.Graphics();
        square.beginFill(0x000000);
        square.drawCircle(eyeX, eyeY + 50, 75);
        square.endFill();
        //app.stage.addChild(square);

        eyeContainer.mask = square;

        app.stage.addChild(eyeContainer)
        */


       
        //pencilTo(1, 0, 2, highlightColor, 290, 170, -120, -20, 0, -50, -120, -45, 0, 1)
        //pencilTo(1, 10, 250, highlightColor, 290, 200, -150, -50, 0, -75, -120, -60, 0, 1)




        var drawLeftHair = function() {
            var template = new PIXI.Graphics();
            if (counter == 1) {
                template.beginFill(hairColor2);
            } else {
                template.beginFill(hairColor1);
            }
            counter++




            template.drawCircle(0, 0, 15);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);



            var randEndX = rand(-200, 150)
            var randEndXP = rand(-200, 250)

            var randEndYP = rand(-50, 50)
            var randEndX1 = rand(-100, 100)

            var randEndXX = rand(0, 100)

            //var randEndYY = rand(250, 500)

            var width = 70
            var endWidth = 70

            var bezier = [{
                x: randEndX1,
                y: -100
            }, {
                x: 0,
                y: randEndYP
            }, {
                x: randEndXP,
                y: 350
            }, {
                x: randEndX,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 3

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    alpha = Math.abs(alpha)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    alpha = 1 - alpha



                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);


                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        container.addChild(duplicate)

                    }


                }

            }

            var containerTwo = new PIXI.ParticleContainer(500000);
            app.stage.addChild(containerTwo)


            var template = new PIXI.Graphics();

            if (counter2 == 1) {
                template.beginFill(hairColor3);
            } else {
                template.beginFill(hairColor4);
            }
            counter2++



            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            app.stage.addChild(template);




            var width = 100
            var endWidth = 100

            var bezier = [{
                x: randEndX1,
                y: -100
            }, {
                x: 0,
                y: 50
            }, {
                x: randEndXP,
                y: 350
            }, {
                x: randEndX - 30,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 20

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    alpha = 1


                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if (j > iterations * 0.70) {
                        offsetY = -drawWidth
                    }
                    if (j > iterations * 0.85) {
                        offsetY = drawWidth
                    }



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerTwo.addChild(duplicate)

                    }


                }

            }



            var template = new PIXI.Graphics();
            template.beginFill(hairColor5);
            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            app.stage.addChild(template);




            var width = rand(1, 3)
            var endWidth = width + 2;

            var bezier = [{
                x: randEndX1 + 110,
                y: -100
            }, {
                x: 100,
                y: 50
            }, {
                x: randEndXP + 90,
                y: 350
            }, {
                x: randEndX + 110,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 0 //rand(10, 20)

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    //alpha = 1


                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if (j > iterations * 0.70) {
                        offsetY = -drawWidth
                    }
                    if (j > iterations * 0.85) {
                        offsetY = drawWidth
                    }



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerTwo.addChild(duplicate)

                    }


                }

            }

            var template = new PIXI.Graphics();
            template.beginFill(hairColor5);
            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            app.stage.addChild(template);




            var width = 2
            var endWidth = 1;

            var bezier = [{
                x: randEndX1 + 110,
                y: -100
            }, {
                x: 100,
                y: 50
            }, {
                x: randEndXP + 90,
                y: 350
            }, {
                x: randEndX + 130,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 5 //0//rand(10, 20)

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    alpha = 1


                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if (j > iterations * 0.70) {
                        offsetY = -drawWidth
                    }
                    if (j > iterations * 0.85) {
                        offsetY = drawWidth
                    }



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerTwo.addChild(duplicate)

                    }


                }

            }



        }

        drawLeftHair();
        drawLeftHair();


       /* var containerThree = new PIXI.ParticleContainer(500000);
        app.stage.addChild(containerThree)

        var drawLeftHairTwo = function() {


            //flick
            var template = new PIXI.Graphics();
            template.beginFill(hairColor2);
            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            var width = 3
            var endWidth = 0

            startX = rand(200, 300)
            OffX = rand(200, 300)

            randEndX = rand(250, 450)
            randEndY = rand(180, 350);

            randPointX = rand(150, 450)

            var bezier = [{
                x: startX,
                y: -100
            }, {
                x: OffX,
                y: -100
            }, {
                x: randPointX,
                y: 150
            }, {
                x: randEndX,
                y: randEndY
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 20 //rand(10, 20)

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerThree.addChild(duplicate)

                    }


                }

            }

        }

        var addHair = rand(0, 1)
        if (addHair) {
            //drawLeftHairTwo();
            //drawLeftHairTwo();
        }*/
    </script>
</body>

</html>