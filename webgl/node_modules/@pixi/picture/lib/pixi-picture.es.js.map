{"version":3,"file":"pixi-picture.es.js","sources":["../src/BlendFilter.ts","../src/FlipYFilter.ts","../src/MaskFilter.ts","../src/ShaderParts.ts","../src/FilterSystemMixin.ts","../src/index.ts"],"sourcesContent":["import {Filter} from '@pixi/core';\r\n\r\n/**\r\n * This filter uses a backdrop texture to calculate the output colors.\r\n *\r\n * A backdrop filter can use existing colors in the destination framebuffer to calculate the\r\n * output colors. It does not need to rely on in-built {@link PIXI.BLEND_MODES blend modes} to\r\n * do those calculations.\r\n */\r\nexport class BackdropFilter extends Filter {\r\n    /**\r\n     * The name of the {@link Filter.uniforms uniform} for the backdrop texture.\r\n     *\r\n     * @pixi/picture's does some mixin magic to bind a copy of destination framebuffer to\r\n     * this uniform.\r\n     */\r\n    backdropUniformName: string = null;\r\n\r\n    /** @ignore */\r\n    _backdropActive = false;\r\n\r\n    /** If non-null, @pixi/picture will clear the filter's output framebuffer with this RGBA color. */\r\n    clearColor: Float32Array = null;\r\n}\r\n\r\n/** A shader part for blending source and destination colors. */\r\nexport interface IBlendShaderParts {\r\n    /**\r\n     * (optional) Code that declares any additional uniforms to be accepted by the {@link BlendFilter}.\r\n     *\r\n     * If you do use this, make sure these uniforms are passed in {@link IBlendShaderParts.uniforms uniforms}.\r\n     */\r\n    uniformCode?: string;\r\n\r\n    /**\r\n     * (optional) Uniforms to pass to the resulting {@link BlendFilter}.\r\n     *\r\n     * Make sure to declare these in {@link IBlendShaderParts.uniformCode uniformCode}.\r\n     */\r\n    uniforms?: { [key: string]: any };\r\n\r\n    /**\r\n     * The blend code that calculates the output color. The following variables are available to\r\n     * this code:\r\n     *\r\n     * | Variable | Type     | Description (colors are usually PMA)       |\r\n     * |----------|----------|--------------------------------------------|\r\n     * | b_src    | vec4     | Source color                               |\r\n     * | b_dst    | vec4     | Destination color                          |\r\n     * | b_res    | vec4     | Output / result color                      |\r\n     */\r\n    blendCode: string;\r\n}\r\n\r\nconst filterFrag = `\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D uBackdrop;\r\nuniform vec2 uBackdrop_flipY;\r\n\r\n%UNIFORM_CODE%\r\n\r\nvoid main(void)\r\n{\r\n   vec2 backdropCoord = vec2(vTextureCoord.x, uBackdrop_flipY.x + uBackdrop_flipY.y * vTextureCoord.y);\r\n   vec4 b_src = texture2D(uSampler, vTextureCoord);\r\n   vec4 b_dest = texture2D(uBackdrop, backdropCoord);\r\n   vec4 b_res = b_dest;\r\n   \r\n   %BLEND_CODE%\r\n\r\n   gl_FragColor = b_res;\r\n}`;\r\n\r\n/**\r\n * A blend filter is a special kind of {@link BackdropFilter} that is used to implement additional blend modes.\r\n *\r\n * The blend filter takes in a {@link IBlendShaderParts} and integrates that code in its shader template to\r\n * blend the source and destination colors.\r\n *\r\n * The backdrop texture uniform for blend filters is {@code \"uBackdrop\"}.\r\n */\r\nexport class BlendFilter extends BackdropFilter {\r\n    /** @param shaderParts - The blending code shader part. */\r\n    constructor(shaderParts: IBlendShaderParts) {\r\n        let fragCode = filterFrag;\r\n        fragCode = fragCode.replace('%UNIFORM_CODE%', shaderParts.uniformCode || \"\");\r\n        fragCode = fragCode.replace('%BLEND_CODE%', shaderParts.blendCode || \"\");\r\n\r\n        super(undefined, fragCode, shaderParts.uniforms);\r\n\r\n        this.backdropUniformName = 'uBackdrop';\r\n    }\r\n}\r\n","import {Filter} from '@pixi/core';\r\nimport type {Dict} from '@pixi/utils';\r\n\r\nconst vert = `\r\nattribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\nuniform vec2 flipY;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n    vTextureCoord.y = flipY.x + flipY.y * vTextureCoord.y;\r\n}\r\n\r\n`;\r\n\r\nexport class FlipYFilter extends Filter {\r\n\tconstructor(frag?: string, uniforms?: Dict<any>) {\r\n\t\tconst uni = uniforms || {};\r\n\t\tif (!uni.flipY) {\r\n\t\t\tuni.flipY = new Float32Array([0.0, 1.0]);\r\n\t\t}\r\n\t\tsuper(vert, frag, uni);\r\n\t}\r\n}\r\n","import { FilterSystem, RenderTexture, Filter } from '@pixi/core';\r\nimport { BLEND_MODES, CLEAR_MODES } from '@pixi/constants';\r\nimport { BlendFilter } from './BlendFilter';\r\nimport { FlipYFilter } from './FlipYFilter';\r\n\r\n/**\r\n * The RGBA channel for {@link MaskFilter} to use to detect the mask region.\r\n *\r\n * When applying a {@link MaskFilter} to a mask {@link DisplayObject}, the object should render\r\n * into that channel. For example, if using the alpha channel - the mask should render with alpha\r\n * 1.0 where-ever the mask region is.\r\n *\r\n * @property {number} RED\r\n * @property {number} GREEN\r\n * @property {number} BLUE\r\n * @property {number} ALPHA\r\n */\r\nexport enum MASK_CHANNEL {\r\n\tRED = 0,\r\n\tGREEN,\r\n\tBLUE,\r\n\tALPHA\r\n}\r\n\r\n/** The mask configuration for {@link MaskFilter}. */\r\nexport class MaskConfig\r\n{\r\n\t/**\r\n\t * @param maskBefore - If true, {@link MaskFilter} will mask the input of the applied filter instead of\r\n\t * \tthe output. In the case of a blur filter, this would cause cause the boundaries of the mask to soften\r\n\t * \tas the blur would apply to the masked region instead of being clipped into it.\r\n\t * @param channel - The mask channel indicating which pixels are in the mask region.\r\n\t */\r\n    constructor(public maskBefore = false, channel: MASK_CHANNEL = MASK_CHANNEL.ALPHA)\r\n    {\r\n        this.uniforms.uChannel[channel] = 1.0;\r\n    }\r\n\r\n\t/** @ignore */\r\n\tuniformCode = 'uniform vec4 uChannel;';\r\n\t/** @ignore */\r\n\tuniforms: any = {\r\n\t    uChannel: new Float32Array([0, 0, 0, 0]), // shared uniform for all those shaders? ok, just set it before apply\r\n\t};\r\n\t/** @ignore */\r\n\tblendCode = `b_res = dot(b_src, uChannel) * b_dest;`;\r\n\r\n\t/**\r\n\t * Flag that indicates the applied filter is Y-symmetric.\r\n\t *\r\n\t * {@link MaskFilter} will optimize rendering by not flipping the screen backdrop before passing it to the\r\n\t * blend filter for Y-symmetric filters.\r\n\t *\r\n\t * A filter is Y-symmetric if giving it an inverted input and then inverting the output is equivalent\r\n\t * to giving it an upright input.\r\n\t */\r\n\tsafeFlipY = false;\r\n}\r\n\r\nconst tmpArray = new Float32Array([0, 1]);\r\n\r\n/**\r\n * A higher-order filter that applies the output of a filter to a masked region of the destination framebuffer.\r\n *\r\n * The masked region is defined by where-ever the target {@link DisplayObject} renders to in the world. For\r\n * example, if you draw a rectangle in the world and apply a masked-blur filter, the blur filter will apply\r\n * to pixels in the backdrop within the rectangle. The {@link DisplayObject} must render by drawing\r\n * a solid RGBA channel (see {@link MaskConfig}'s constructor).\r\n */\r\nexport class MaskFilter extends BlendFilter\r\n{\r\n\t/**\r\n\t * @param baseFilter - The filter being applied.\r\n\t * @param config - The configuration for the mask.\r\n\t */\r\n    constructor(public baseFilter: Filter, public config: MaskConfig = new MaskConfig())\r\n    {\r\n        super(config);\r\n        this.padding = baseFilter.padding;\r\n        this.safeFlipY = config.safeFlipY;\r\n    }\r\n\r\n\t/** @ignore */\r\n\tstatic _flipYFilter: FlipYFilter = null;\r\n\r\n\t/**\r\n\t * if base filter is not sensitive to flipping Y axis, you can turn this ON and save a temporary texture bind / drawcall\r\n\t */\r\n\tsafeFlipY: boolean;\r\n\r\n\tapply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\r\n\t      clearMode: CLEAR_MODES): void\r\n\t{\r\n\t    const target = filterManager.getFilterTexture(input);\r\n\r\n\t    if (this.config.maskBefore)\r\n\t    {\r\n\t        const { blendMode } = this.state;\r\n\r\n\t        this.state.blendMode = BLEND_MODES.NONE;\r\n\t        filterManager.applyFilter(this, input, target, CLEAR_MODES.YES);\r\n\t        this.baseFilter.blendMode = blendMode;\r\n\t        this.baseFilter.apply(filterManager, target, output, clearMode);\r\n\t        this.state.blendMode = blendMode;\r\n\t    }\r\n\t    else\r\n\t    {\r\n\t        const { uBackdrop, uBackdrop_flipY } = this.uniforms;\r\n\r\n\t        if (uBackdrop_flipY[1] > 0 || this.safeFlipY)\r\n\t        {\r\n\t            this.baseFilter.apply(filterManager, uBackdrop, target, CLEAR_MODES.YES);\r\n\t        }\r\n\t        else\r\n\t        {\r\n\t            // in case there was a flip and base filter is not flipY-safe, we have to use extra flip operation\r\n\t            const targetFlip = filterManager.getFilterTexture(input);\r\n\r\n\t            if (!MaskFilter._flipYFilter)\r\n\t            {\r\n\t                MaskFilter._flipYFilter = new FlipYFilter();\r\n\t            }\r\n\t            MaskFilter._flipYFilter.uniforms.flipY[0] = uBackdrop_flipY[0];\r\n\t            MaskFilter._flipYFilter.uniforms.flipY[1] = uBackdrop_flipY[1];\r\n\t            MaskFilter._flipYFilter.apply(filterManager, uBackdrop, targetFlip, CLEAR_MODES.YES);\r\n\t            this.baseFilter.apply(filterManager, targetFlip, target, CLEAR_MODES.YES);\r\n\t            filterManager.returnFilterTexture(targetFlip);\r\n\t            this.uniforms.uBackdrop_flipY = tmpArray;\r\n\t        }\r\n\t        this.uniforms.uBackdrop = target;\r\n\t        filterManager.applyFilter(this, input, output, clearMode);\r\n\t        this.uniforms.uBackdrop = uBackdrop;\r\n\t        this.uniforms.uBackdrop_flipY = uBackdrop_flipY;\r\n\t    }\r\n\t    filterManager.returnFilterTexture(target);\r\n\t}\r\n}\r\n","import {BlendFilter} from \"./BlendFilter\";\r\nimport {BLEND_MODES} from \"@pixi/constants\";\r\n\r\nexport const NPM_BLEND: string =\r\n    `if (b_src.a == 0.0) {\r\n  gl_FragColor = vec4(0, 0, 0, 0);\r\n  return;\r\n}\r\nif (b_dest.a == 0.0) {\r\n  gl_FragColor = b_src;\r\n  return;\r\n}\r\nvec3 Cb = b_dest.rgb / b_dest.a;\r\nvec3 Cs = b_src.rgb / b_src.a;\r\n%NPM_BLEND%\r\n// SWAP SRC WITH NPM BLEND\r\nvec3 new_src = (1.0 - b_dest.a) * Cs + b_dest.a * B;\r\n// PORTER DUFF PMA COMPOSITION MODE\r\nb_res.a = b_src.a + b_dest.a * (1.0-b_src.a);\r\nb_res.rgb = b_src.a * new_src + (1.0 - b_src.a) * b_dest.rgb;\r\n`;\r\n\r\n//reverse hardlight\r\nexport const OVERLAY_PART: string =\r\n    `vec3 multiply = Cb * Cs * 2.0;\r\nvec3 Cb2 = Cb * 2.0 - 1.0;\r\nvec3 screen = Cb2 + Cs - Cb2 * Cs;\r\nvec3 B;\r\nif (Cb.r <= 0.5) {\r\n  B.r = multiply.r;\r\n} else {\r\n  B.r = screen.r;\r\n}\r\nif (Cb.g <= 0.5) {\r\n  B.g = multiply.g;\r\n} else {\r\n  B.g = screen.g;\r\n}\r\nif (Cb.b <= 0.5) {\r\n  B.b = multiply.b;\r\n} else {\r\n  B.b = screen.b;\r\n}\r\n`;\r\n\r\nexport const HARDLIGHT_PART: string =\r\n    `vec3 multiply = Cb * Cs * 2.0;\r\nvec3 Cs2 = Cs * 2.0 - 1.0;\r\nvec3 screen = Cb + Cs2 - Cb * Cs2;\r\nvec3 B;\r\nif (Cs.r <= 0.5) {\r\n  B.r = multiply.r;\r\n} else {\r\n  B.r = screen.r;\r\n}\r\nif (Cs.g <= 0.5) {\r\n  B.g = multiply.g;\r\n} else {\r\n  B.g = screen.g;\r\n}\r\nif (Cs.b <= 0.5) {\r\n  B.b = multiply.b;\r\n} else {\r\n  B.b = screen.b;\r\n}\r\n`;\r\n\r\nexport const SOFTLIGHT_PART: string =\r\n    `vec3 first = Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\r\nvec3 B;\r\nvec3 D;\r\nif (Cs.r <= 0.5)\r\n{\r\n  B.r = first.r;\r\n}\r\nelse\r\n{\r\n  if (Cb.r <= 0.25)\r\n  {\r\n    D.r = ((16.0 * Cb.r - 12.0) * Cb.r + 4.0) * Cb.r;    \r\n  }\r\n  else\r\n  {\r\n    D.r = sqrt(Cb.r);\r\n  }\r\n  B.r = Cb.r + (2.0 * Cs.r - 1.0) * (D.r - Cb.r);\r\n}\r\nif (Cs.g <= 0.5)\r\n{\r\n  B.g = first.g;\r\n}\r\nelse\r\n{\r\n  if (Cb.g <= 0.25)\r\n  {\r\n    D.g = ((16.0 * Cb.g - 12.0) * Cb.g + 4.0) * Cb.g;    \r\n  }\r\n  else\r\n  {\r\n    D.g = sqrt(Cb.g);\r\n  }\r\n  B.g = Cb.g + (2.0 * Cs.g - 1.0) * (D.g - Cb.g);\r\n}\r\nif (Cs.b <= 0.5)\r\n{\r\n  B.b = first.b;\r\n}\r\nelse\r\n{\r\n  if (Cb.b <= 0.25)\r\n  {\r\n    D.b = ((16.0 * Cb.b - 12.0) * Cb.b + 4.0) * Cb.b;    \r\n  }\r\n  else\r\n  {\r\n    D.b = sqrt(Cb.b);\r\n  }\r\n  B.b = Cb.b + (2.0 * Cs.b - 1.0) * (D.b - Cb.b);\r\n}\r\n`;\r\n\r\nexport const MULTIPLY_PART: string =\r\n    `vec3 B = Cs * Cb;\r\n`;\r\nexport const OVERLAY_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, OVERLAY_PART);\r\nexport const HARDLIGHT_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, HARDLIGHT_PART);\r\nexport const SOFTLIGHT_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, SOFTLIGHT_PART);\r\nexport const MULTIPLY_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, MULTIPLY_PART);\r\n\r\n/**\r\n * Maps {@link PIXI.BLEND_MODES blend modes} to {@link IBlendShaderParts.blendCode blend code}.\r\n *\r\n * This library provides blending code for {@link BLEND_MODES.MULTIPLY}, {@link BLEND_MODES.OVERLAY},\r\n * {@link BLEND_MODES.HARD_LIGHT}, {@link BLEND_MODES.SOFT_LIGHT}. If you add blend modes to the\r\n * {@link PIXI.BLEND_MODES} enumeration, you can implement them by augmenting this map with your shader\r\n * code.\r\n *\r\n * @type {object<string, string>}\r\n */\r\nexport const blendFullArray: Array<string> = [];\r\n\r\nblendFullArray[BLEND_MODES.MULTIPLY] = MULTIPLY_FULL;\r\nblendFullArray[BLEND_MODES.OVERLAY] = OVERLAY_FULL;\r\nblendFullArray[BLEND_MODES.HARD_LIGHT] = HARDLIGHT_FULL;\r\nblendFullArray[BLEND_MODES.SOFT_LIGHT] = SOFTLIGHT_FULL;\r\n\r\nconst filterCache: Array<BlendFilter> = [];\r\nconst filterCacheArray: Array<Array<BlendFilter>> = [];\r\n\r\n/**\r\n * Get a memoized {@link BlendFilter} for the passed blend mode. This expects {@link blendFullArray}\r\n * to have the blending code beforehand.\r\n *\r\n * If you changed the blending code in {@link blendFullArray}, this won't create a new blend filter\r\n * due to memoization!\r\n *\r\n * @param blendMode - The blend mode desired.\r\n */\r\nexport function getBlendFilter(blendMode: BLEND_MODES) {\r\n    if (!blendFullArray[blendMode]) {\r\n        return null;\r\n    }\r\n    if (!filterCache[blendMode]) {\r\n        filterCache[blendMode] = new BlendFilter({blendCode: blendFullArray[blendMode]});\r\n    }\r\n    return filterCache[blendMode];\r\n}\r\n\r\n/**\r\n * Similar to {@link getBlendFilter}, but wraps the filter in a memoized array.\r\n *\r\n * This is useful when assigning {@link PIXI.Container.filters} as a new array will not be created\r\n * per re-assigment.\r\n *\r\n * ```\r\n * import { getBlendFilter, getBlendFilterArray } from '@pixi/picture';\r\n *\r\n * // Don't do\r\n * displayObject.filters = [getBlendFilter(BLEND_MODES.OVERLAY)];\r\n *\r\n * // Do\r\n * displayObject.filters = getBlendFilterArray(BLEND_MODES.OVERLAY);\r\n * ```\r\n *\r\n * @param blendMode - The blend mode desired.\r\n */\r\nexport function getBlendFilterArray(blendMode: BLEND_MODES) {\r\n    if (!blendFullArray[blendMode]) {\r\n        return null;\r\n    }\r\n    if (!filterCacheArray[blendMode]) {\r\n        filterCacheArray[blendMode] = [getBlendFilter(blendMode)];\r\n    }\r\n    return filterCacheArray[blendMode];\r\n}\r\n","import {TextureSystem, FilterSystem, BaseTexture, RenderTexture, Filter, FilterState} from '@pixi/core';\r\nimport {CLEAR_MODES} from '@pixi/constants';\r\nimport {Matrix, Rectangle} from '@pixi/math';\r\nimport {DisplayObject} from '@pixi/display';\r\nimport {BackdropFilter} from \"./BlendFilter\";\r\n\r\nexport interface IPictureFilterSystem extends FilterSystem {\r\n    prepareBackdrop(sourceFrame: Rectangle, flipY: Float32Array): RenderTexture;\r\n\r\n    pushWithCheck(target: DisplayObject, filters: Array<Filter>, checkEmptyBounds?: boolean): boolean;\r\n}\r\n\r\nexport interface IPictureTextureSystem extends TextureSystem {\r\n    bindForceLocation(texture: BaseTexture, location: number): void;\r\n}\r\n\r\nfunction containsRect(rectOut: Rectangle, rectIn: Rectangle): boolean {\r\n    let r1 = rectIn.x + rectIn.width;\r\n    let b1 = rectIn.y + rectIn.height;\r\n    let r2 = rectOut.x + rectOut.width;\r\n    let b2 = rectOut.y + rectOut.height;\r\n    return (rectIn.x >= rectOut.x) &&\r\n        (rectIn.x <= r2) &&\r\n        (rectIn.y >= rectOut.y) &&\r\n        (rectIn.y <= b2) &&\r\n        (r1 >= rectOut.x) &&\r\n        (r1 <= r2) &&\r\n        (b1 >= rectOut.y) &&\r\n        (b1 <= b2);\r\n}\r\n\r\nfunction bindForceLocation(this: IPictureTextureSystem, texture: BaseTexture, location = 0) {\r\n    const { gl } = this;\r\n    if (this.currentLocation !== location)\r\n    {\r\n        this.currentLocation = location;\r\n        gl.activeTexture(gl.TEXTURE0 + location);\r\n    }\r\n    this.bind(texture, location);\r\n}\r\n\r\nconst tempMatrix = new Matrix();\r\n\r\nfunction pushWithCheck(this: IPictureFilterSystem,\r\n              target: DisplayObject, filters: Array<BackdropFilter>, checkEmptyBounds: boolean = true) {\r\n    const renderer = this.renderer;\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = this.statePool.pop() || new FilterState();\r\n    const renderTextureSystem = this.renderer.renderTexture;\r\n\r\n    let resolution = filters[0].resolution;\r\n    let padding = filters[0].padding;\r\n    let autoFit = filters[0].autoFit;\r\n    let legacy = filters[0].legacy;\r\n\r\n    for (let i = 1; i < filters.length; i++)\r\n    {\r\n        const filter = filters[i];\r\n\r\n        resolution = Math.min(resolution, filter.resolution);\r\n        padding = this.useMaxPadding\r\n            ? Math.max(padding, filter.padding)\r\n            : padding + filter.padding;\r\n        autoFit = autoFit && filter.autoFit;\r\n\r\n        legacy = legacy || filter.legacy;\r\n    }\r\n\r\n    if (filterStack.length === 1)\r\n    {\r\n        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\r\n    }\r\n\r\n    filterStack.push(state);\r\n\r\n    state.resolution = resolution;\r\n\r\n    state.legacy = legacy;\r\n\r\n    state.target = target;\r\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\r\n\r\n    state.sourceFrame.pad(padding);\r\n\r\n    let canUseBackdrop = true;\r\n    if (autoFit)\r\n    {\r\n        const sourceFrameProjected = (this as any).tempRect.copyFrom(renderTextureSystem.sourceFrame);\r\n\r\n        // Project source frame into world space (if projection is applied)\r\n        if (renderer.projection.transform)\r\n        {\r\n            (this as any).transformAABB(\r\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\r\n                sourceFrameProjected\r\n            );\r\n        }\r\n\r\n        state.sourceFrame.fit(sourceFrameProjected);\r\n    } else {\r\n        //check if backdrop is obtainable after rejecting autoFit\r\n        canUseBackdrop = containsRect(this.renderer.renderTexture.sourceFrame, state.sourceFrame);\r\n    }\r\n\r\n    if (checkEmptyBounds && state.sourceFrame.width <= 1 && state.sourceFrame.height <= 1) {\r\n        filterStack.pop();\r\n        state.clear();\r\n        this.statePool.push(state);\r\n        return false;\r\n    }\r\n    (this as any).roundFrame(\r\n        state.sourceFrame,\r\n        renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\r\n        renderTextureSystem.sourceFrame,\r\n        renderTextureSystem.destinationFrame,\r\n        renderer.projection.transform,\r\n    );\r\n\r\n    // round to whole number based on resolution\r\n    state.sourceFrame.ceil(resolution);\r\n\r\n    // detect backdrop uniform\r\n    if (canUseBackdrop) {\r\n        let backdrop = null;\r\n        let backdropFlip = null;\r\n        for (let i = 0; i < filters.length; i++) {\r\n            const bName = filters[i].backdropUniformName;\r\n            if (bName) {\r\n                const { uniforms } = filters[i];\r\n                if (!uniforms[bName + '_flipY']) {\r\n                    uniforms[bName + '_flipY'] = new Float32Array([0.0, 1.0]);\r\n                }\r\n                const flip = uniforms[bName + '_flipY'];\r\n                if (backdrop === null) {\r\n                    backdrop = this.prepareBackdrop(state.sourceFrame, flip);\r\n                    backdropFlip = flip;\r\n                } else {\r\n                    flip[0] = backdropFlip[0];\r\n                    flip[1] = backdropFlip[1];\r\n                }\r\n\r\n                uniforms[bName] = backdrop;\r\n                if (backdrop) {\r\n                    filters[i]._backdropActive = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (backdrop)\r\n        {\r\n            resolution = state.resolution = backdrop.resolution;\r\n        }\r\n    }\r\n\r\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);\r\n    state.filters = filters;\r\n\r\n    state.destinationFrame.width = state.renderTexture.width;\r\n    state.destinationFrame.height = state.renderTexture.height;\r\n\r\n    const destinationFrame = (this as any).tempRect;\r\n\r\n    destinationFrame.x = 0;\r\n    destinationFrame.y = 0;\r\n    destinationFrame.width = state.sourceFrame.width;\r\n    destinationFrame.height = state.sourceFrame.height;\r\n\r\n    state.renderTexture.filterFrame = state.sourceFrame;\r\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\r\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\r\n\r\n    state.transform = renderer.projection.transform;\r\n    renderer.projection.transform = null;\r\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\r\n\r\n    const cc = filters[filters.length - 1].clearColor as any;\r\n\r\n    if (cc) {\r\n        // take clear color from filter, it helps for advanced DisplacementFilter\r\n        renderer.framebuffer.clear(cc[0], cc[1], cc[2], cc[3]);\r\n    } else {\r\n        renderer.framebuffer.clear(0, 0, 0, 0);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction push(this: IPictureFilterSystem,\r\n              target: DisplayObject, filters: Array<Filter>) {\r\n    return this.pushWithCheck(target, filters, false);\r\n}\r\n\r\nfunction pop(this: IPictureFilterSystem) {\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = filterStack.pop();\r\n    const filters = state.filters as Array<BackdropFilter>;\r\n\r\n    this.activeState = state;\r\n\r\n    const globalUniforms = this.globalUniforms.uniforms;\r\n\r\n    globalUniforms.outputFrame = state.sourceFrame;\r\n    globalUniforms.resolution = state.resolution;\r\n\r\n    const inputSize = globalUniforms.inputSize;\r\n    const inputPixel = globalUniforms.inputPixel;\r\n    const inputClamp = globalUniforms.inputClamp;\r\n\r\n    inputSize[0] = state.destinationFrame.width;\r\n    inputSize[1] = state.destinationFrame.height;\r\n    inputSize[2] = 1.0 / inputSize[0];\r\n    inputSize[3] = 1.0 / inputSize[1];\r\n\r\n    inputPixel[0] = inputSize[0] * state.resolution;\r\n    inputPixel[1] = inputSize[1] * state.resolution;\r\n    inputPixel[2] = 1.0 / inputPixel[0];\r\n    inputPixel[3] = 1.0 / inputPixel[1];\r\n\r\n    inputClamp[0] = 0.5 * inputPixel[2];\r\n    inputClamp[1] = 0.5 * inputPixel[3];\r\n    inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\r\n    inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\r\n\r\n    // only update the rect if its legacy..\r\n    if (state.legacy)\r\n    {\r\n        const filterArea = globalUniforms.filterArea;\r\n\r\n        filterArea[0] = state.destinationFrame.width;\r\n        filterArea[1] = state.destinationFrame.height;\r\n        filterArea[2] = state.sourceFrame.x;\r\n        filterArea[3] = state.sourceFrame.y;\r\n\r\n        globalUniforms.filterClamp = globalUniforms.inputClamp;\r\n    }\r\n\r\n    this.globalUniforms.update();\r\n\r\n    const lastState = filterStack[filterStack.length - 1];\r\n\r\n    if (state.renderTexture.framebuffer.multisample > 1)\r\n    {\r\n        this.renderer.framebuffer.blit();\r\n    }\r\n\r\n    if (filters.length === 1)\r\n    {\r\n        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(state.renderTexture);\r\n    }\r\n    else\r\n    {\r\n        let flip = state.renderTexture;\r\n        let flop = this.getOptimalFilterTexture(\r\n            flip.width,\r\n            flip.height,\r\n            state.resolution\r\n        );\r\n\r\n        flop.filterFrame = flip.filterFrame;\r\n\r\n        let i = 0;\r\n\r\n        for (i = 0; i < filters.length - 1; ++i)\r\n        {\r\n            filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\r\n\r\n            const t = flip;\r\n\r\n            flip = flop;\r\n            flop = t;\r\n        }\r\n\r\n        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(flip);\r\n        this.returnFilterTexture(flop);\r\n    }\r\n\r\n    // release the backdrop!\r\n    let backdropFree = false;\r\n\r\n    for (let i = 0; i < filters.length; i++) {\r\n        if (filters[i]._backdropActive) {\r\n            const bName = filters[i].backdropUniformName;\r\n            if (!backdropFree) {\r\n                this.returnFilterTexture(filters[i].uniforms[bName]);\r\n                backdropFree = true;\r\n            }\r\n            filters[i].uniforms[bName] = null;\r\n            filters[i]._backdropActive = false;\r\n        }\r\n    }\r\n\r\n    state.clear();\r\n    this.statePool.push(state);\r\n}\r\n\r\nlet hadBackbufferError = false;\r\n\r\n/**\r\n * Takes a part of current render target corresponding to bounds\r\n * fits sourceFrame to current render target frame to evade problems\r\n */\r\nfunction prepareBackdrop(bounds: Rectangle, flipY: Float32Array): RenderTexture {\r\n    const renderer = this.renderer;\r\n    const renderTarget = renderer.renderTexture.current;\r\n    const fr = this.renderer.renderTexture.sourceFrame;\r\n    const tf = renderer.projection.transform || Matrix.IDENTITY;\r\n\r\n    //TODO: take non-standart sourceFrame/destinationFrame into account, all according to ShukantPal refactoring\r\n\r\n    let resolution = 1;\r\n    if (renderTarget) {\r\n        resolution = renderTarget.baseTexture.resolution;\r\n        flipY[1] = 1.0;\r\n    } else {\r\n        if (!renderer.useContextAlpha) {\r\n            if (!hadBackbufferError) {\r\n                hadBackbufferError = true;\r\n                console.warn('pixi-picture: you are trying to use Blend Filter on main framebuffer! That wont work.');\r\n            }\r\n            return null;\r\n        }\r\n        resolution = renderer.resolution;\r\n        flipY[1] = -1.0;\r\n    }\r\n\r\n    //bounds.fit(fr);\r\n\r\n    const x = Math.round((bounds.x - fr.x + tf.tx) * resolution);\r\n    const dy = bounds.y - fr.y + tf.ty;\r\n    const y = Math.round((flipY[1] < 0.0 ? fr.height - (dy + bounds.height) : dy) * resolution);\r\n    const w = Math.round(bounds.width * resolution);\r\n    const h = Math.round(bounds.height * resolution);\r\n\r\n    const gl = renderer.gl;\r\n    const rt = this.getOptimalFilterTexture(w, h, 1);\r\n\r\n    if (flipY[1] < 0) {\r\n        flipY[0] = h / rt.height;\r\n    }\r\n\r\n    rt.filterFrame = fr;\r\n    rt.setResolution(resolution);\r\n    renderer.texture.bindForceLocation(rt.baseTexture, 0);\r\n    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, w, h);\r\n    return rt;\r\n}\r\n\r\nexport function applyMixins() {\r\n    (TextureSystem as any).prototype.bindForceLocation = bindForceLocation;\r\n    (FilterSystem as any).prototype.push = push;\r\n    (FilterSystem as any).prototype.pushWithCheck = pushWithCheck as any;\r\n    (FilterSystem as any).prototype.pop = pop;\r\n    (FilterSystem as any).prototype.prepareBackdrop = prepareBackdrop;\r\n}\r\n","export * from './BlendFilter';\r\nexport * from './FlipYFilter';\r\nexport * from './MaskFilter';\r\nexport * from './ShaderParts';\r\nexport * from './Sprite';\r\nexport * from './TilingSprite';\r\nimport {IPictureFilterSystem, IPictureTextureSystem, applyMixins} from \"./FilterSystemMixin\";\r\nexport {IPictureFilterSystem, IPictureTextureSystem, applyMixins};\r\n\r\napplyMixins();\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAsDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACcA;;;;;AAKA;;;;;;;;;;;;;AAqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC0DR;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;AAmBA;;;;;;;;;AA4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClLA;;;;;;;;;;;;;AAaA;AAEA;;;;;;;AAQA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8IA;AAEA;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyGA;AAEA;AAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;;;;;;;AAQA;;AC5VA;;;;"}