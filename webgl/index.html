<html>

<head>
    <title>ggg</title>
    <style>
        body {
            background-color: grey;
        }
        
        #canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateX(-50%) translateY(-50%);
        }
    </style>
</head>

<body>

    <img src="trace.png" style="height:400px;width:400px;object-fit: cover;">
    <img src="trace-2.png" style="height:400px;width:400px;object-fit: cover;">
    <img src="trace-3.png" style="height:400px;width:400px;object-fit: cover;">
    <img src="trace-4.png" style="height:400px;width:400px;object-fit: cover;">

    <script src="pixi.js"></script>
    <script src="pixi-picture.umd.js"></script>
    <script src="curves.js"></script>
    <script src="perlin.js"></script>
    <script src="numbers.js"></script>
    <script src="bezier-easing.js"></script>
    <script src="chroma.js"></script>

    <script>
        let app = new PIXI.Application({
            width: 400,
            height: 400,
            antialias: true,
            resolution: 1,
            forceCanvas: true,
            roundPixels: true,
        });
        document.body.appendChild(app.view);


        var counter = 0
        var counter2 = 0


        let randomColor = rand(0, 360);

        let hairColor = chroma(randomColor, 0.8, 0.5, 'hsl');
        let highlightColor = chroma(randomColor + 230, 0.8, 0.6, 'hsl');
        var multiplyColor = chroma.blend(hairColor, highlightColor, 'multiply');
        
        var eyebrowColor = chroma.blend(hairColor, highlightColor, 'multiply');

        hairColors = multiplyColor
        hairColorsDark = chroma.scale([hairColors, 'black']).colors(4);
        hairColorsLight = chroma.scale([hairColors, 'white']).colors(5);
        hairColorsLightTwo = chroma.scale([hairColors, 'white']).colors(30);
        let backgroundColor = hairColorsLightTwo[28];
        backgroundColor = PIXI.utils.string2hex(backgroundColor)


        let bk = new PIXI.Graphics();
        bk.beginFill(backgroundColor);
        bk.drawRect(0, 0, 500, 500);
        bk.endFill();
        app.stage.addChild(bk)

        let color1 = new PIXI.Graphics();
        hairColor = PIXI.utils.string2hex(hairColor.hex())
        color1.beginFill(hairColor);
        color1.drawRect(0, 0, 10, 10);
        color1.endFill();
        app.stage.addChild(color1);

        let color2 = new PIXI.Graphics();
        highlightColor = PIXI.utils.string2hex(highlightColor.hex())
        color2.beginFill(highlightColor);
        color2.drawRect(10, 0, 10, 10);
        color2.endFill();
        app.stage.addChild(color2);

        let color3 = new PIXI.Graphics();
        multiplyColor = PIXI.utils.string2hex(multiplyColor.hex())
        color3.beginFill(multiplyColor);
        color3.drawRect(20, 0, 10, 10);
        color3.endFill();
        app.stage.addChild(color3);

        var container = new PIXI.ParticleContainer(500000);
        app.stage.addChild(container)


        let hairColor1 = PIXI.utils.string2hex(hairColorsDark[3])
        let hairColor2 = PIXI.utils.string2hex(hairColorsDark[2])
        let hairColor3 = PIXI.utils.string2hex(hairColorsDark[1])
        let hairColor4 = PIXI.utils.string2hex(hairColorsDark[0])
        let hairColor5 = PIXI.utils.string2hex(hairColorsLight[1])


        let startColor = chroma(randomColor, 0.3, 0.5, 'hsl');
        let endColor = chroma(randomColor + 115, 0.5, 0.6, 'hsl');
        startColor = chroma(startColor).hex()
        endColor = chroma(endColor).hex()
        startColor = PIXI.utils.string2hex(startColor)
        endColor = PIXI.utils.string2hex(endColor)


        

        eyebrowColor = chroma(multiplyColor).hex()

        




        
        class pencil {
            constructor({startWidth,endWidth,shape,iterations,color,alpha,alphaEasing,nib,nibOption,angle,fadeAngle,widthArray,pressureArray}) {
                this.startWidth = startWidth || 1;
                this.endWidth = endWidth || 1;
                this.shape = shape;
                this.iterations = iterations || 1;
                this.color = color || '#000000';
                this.alpha = alpha || 1;
                this.alphaEasing = 'linear';
                this.nib = nib;
                this.nibOption = nibOption || this.startWidth;
                this.angle = 0;
                this.fadeAngle = 0;
                this.widthArray = [];
                this.pressureArray = [];
                this.layer = new PIXI.Graphics();
            }
        }

        class line {
            constructor({x,y,cp1,cp2,endX,endY,cp3,cp4}) {
                this.x = x;
                this.y = y;
                this.cp1 = cp1;
                this.cp2 = cp2;
                this.endX = endX;
                this.endY = endY;
                this.cp3 = cp3;
                this.cp4 = cp4;
            }
        }




        let drawLine = function(line, pencil, layer) {

            bezierPoints = createBezierPoints(line);

            lineGraphic = new PIXI.Container();

            color = PIXI.utils.string2hex(pencil.color)

            var widthFactor = (pencil.startWidth - pencil.endWidth) / bezierPoints.length

            //linear easing
            var easing = bezier(0, 0, 1, 1);
            //var easing = bezier(0.32, 0, 0.67, 0);
            //var easing = bezier(0.12, 0, 0.39, 0);
            //var easing = bezier(0.64, 0, 0.78, 0);
            //var easing = bezier(0.55, 0, 1, 0.45);
            //var easing = bezier(0.46, 0, .01, 1);
            //var easing = bezier(.99,-0.01,.61,1);

            var newBezierPoints = [];
            //Remove points from the bezier curve using the shape of an easing function
            var previousValue
            for (var i = 0; i < bezierPoints.length; i++) {
                var value = easing(i / bezierPoints.length);
                var value = Math.round(value*bezierPoints.length)
                if(value != previousValue) {
                    newBezierPoints.push(bezierPoints[i])
                }
                previousValue = value
            }
            //bezierPoints = newBezierPoints;

            //Apply perlin noise to each point of the bezier curve
            for (var i = 0; i < bezierPoints.length; i++) {
                offset = perlin.get(bezierPoints[i].x, bezierPoints[i].y)
                bezierPoints[i].x = bezierPoints[i].x + (offset*2)
                bezierPoints[i].y = bezierPoints[i].y + (offset*2)
            }
            
            let dotGraphic = new PIXI.Graphics();

            let pixel = new PIXI.Graphics();
            pixel.beginFill(color, alpha);
            pixel.drawCircle(0, 0, 1);
            pixel.endFill();
            var texture = app.renderer.generateTexture(pixel);
            

            for (var i=0; i<pencil.iterations; i++ ) {

                var points = [null, null, null];

                console.log(bezierPoints.length)
                
                for(var j=0; j<bezierPoints.length; j++) {

                    var drawPoint = getBezierPoint(points, bezierPoints[j].x, bezierPoints[j].y);
                    
                    if(drawPoint == null)
                        continue;
                        
                    var drawWidth = pencil.startWidth - (widthFactor * j)
                    
                    var percent = (j / bezierPoints.length);
                    var alpha = pencil.alpha
                    //var easingAlphaPercentage = pencil.alpha * 10
                    //var alpha = easing(percent/easingAlphaPercentage);
                    //var alpha = alpha / 10
                    var radius = drawWidth
                    var alpha = perlin.get(drawPoint[0], drawPoint[1])
                    if(alpha < 0.1) {
                        alpha = 0.1
                    }

                    //var alphaOffset = perlin.get(drawPoint[0], drawPoint[1])
                    //alphaOffset = Math.abs(alphaOffset)
                    //alpha = alpha - (alphaOffset/easingAlphaPercentage / 2)

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if(offsetX < 0) {
                        offsetX = rand(0, radius/4);
                    }
                    if(offsetY < 0) {
                        offsetY = rand(0, radius/4);
                    }

                    var drawX, drawY;
                
                    //console.log(pencil.alpha)

                    if(pencil.nib == 'circle') {
                        var angle = Math.random() * Math.PI * 2;
                        drawX = drawPoint[0] + offsetX * Math.sin(angle);
                        drawY = drawPoint[1] + offsetX * Math.cos(angle);
                    } else if (pencil.nib == 'oval') {
                        var firstAngle = pencil.startWidth
                        var secondAngle = pencil.nibOption
                        r = firstAngle * Math.sqrt(Math.random(0,.1))
                        fi = 2 * Math.PI * Math.random(0,.1)
                        drawX = drawPoint[0] + r * Math.cos(fi)
                        drawY = drawPoint[1] + secondAngle / firstAngle *  r * Math.sin(fi)
                    } else {
                        drawX = drawPoint[0] + offsetX;
                        drawY = drawPoint[1] + offsetY;
                    }

                    //let sprite = new PIXI.Sprite(texture);
                    //sprite.x = drawX;
                    //sprite.y = drawY;
                    //sprite.alpha = alpha;
                    //lineGraphic.addChild(sprite);

                    
                    dotGraphic.beginFill(color, alpha);
                    dotGraphic.drawCircle(drawX, drawY, 1);
                    dotGraphic.endFill();
                    lineGraphic.addChild(dotGraphic);

                            

                }
                
            }

            layer.addChild(lineGraphic);

        }

        



        
        var eyeContainer = new PIXI.Container();

        

       










        var pencilTo = function(width, endWidth, iterations, color, startX, startY, endX, endY, cp1, cp2, cp3, cp4, circle, size) {
          
          color = PIXI.utils.string2hex(color)

          let newEndX = startX + endX
          let newEndY = startY + endY
        
          let cp1Local = startX + cp1
          let cp2Local = startY + cp2
        
          let cp3Local = startX + cp3
          let cp4Local = startY + cp4
        
          var bezier = [{x: startX, y: startY}, {x: cp1Local, y: cp2Local}, {x: cp3Local, y:cp4Local}, {x:newEndX, y:newEndY}]
        
          var bezierPoints = findCBezPoints(bezier);
        
          var widthFactor = (width - endWidth) / bezierPoints.length
          
          template = new PIXI.Graphics();


          for (var j=0; j<iterations; j++ ) {

            var points = [null, null, null];
  
            for(var i=0; i<bezierPoints.length; i++) {

              var drawWidth = width - (widthFactor * i)

              var x = bezierPoints[i].x;
              var y = bezierPoints[i].y;
        
              points[0] = points[1];
              points[1] = points[2];
              points[2] = { X:x, Y:y};
        
              if(points[0] == null)
                  continue;
        
              var p0 = points[0];
              var p1 = points[1];
              var p2 = points[2];
        
              var x0 = (p0.X + p1.X) / 2;
              var y0 = (p0.Y + p1.Y) / 2;
  
                //ctx.moveTo(x0, y0);
        
                var alpha = perlin.get(x0, y0)
        
                if(alpha < 0.1) {
                alpha = 0.1
                }
        
                if(i > bezierPoints.length*0.5 && drawWidth < 1) {
                let fader = (drawWidth/i)*2
                //alpha = alpha - fader
                //console.log(alpha)
                }
        
        //ctx.globalAlpha = alpha
  
                var radius = drawWidth
        
                
        
                var offsetX = rand(-radius, radius);
                var offsetY = rand(-radius, radius);
                
                var randomX = x0 + offsetX;
                var randomY = y0 + offsetY;

                randomX = x0 + radius * 2 * Math.random() - radius;
                randomY = y0 + radius * 2 * Math.random() - radius;

                // Circle Form 
                var angle = Math.random() * Math.PI * 2;
                randomX = x0 + offsetX * Math.sin(angle);
                randomY = y0 + offsetX * Math.cos(angle);

                //Ellipsis Form
                if(width == 40) {
                    var firstAngle = irisSize
                    var secondAngle = irisSizeY
                    r = firstAngle * Math.sqrt(Math.random(0,.1))
                    fi = 2 * Math.PI * Math.random(0,.1)
                    randomX = x0 + r * Math.cos(fi)
                    randomY = y0 + secondAngle / firstAngle *  r * Math.sin(fi)
                }
                
                template.beginFill(color, alpha);
                template.drawCircle(randomX, randomY, size);
                template.endFill();

            }

          }

          
          eyeContainer.addChild(template);



        }

        














        
        hairColorBrightness = chroma(hairColor).luminance()
        highlightColorBrightness = chroma(highlightColor).luminance()
        multiplyColorBrightness = chroma(multiplyColor).luminance()
        
        if(multiplyColorBrightness > 0.25) {
          multiplyColor = chroma(multiplyColor).darken(0.8)
        }

        if(hairColorBrightness < highlightColorBrightness) {
          replaceColor = highlightColor
          highlightColor = hairColor
          hairColor = replaceColor
        }

        hairColor = chroma(hairColor).hex()
        multiplyColor = chroma(multiplyColor).hex()
        highlightColor = chroma(highlightColor).hex()


        eyeY = rand(155, 175)
        eyeX = rand(190, 210)

        irisSize = 40
        irisSizeY = rand(35, 45)

        var eyeContainer = new PIXI.Container();

        var irisContainer = new PIXI.Container();
        let irisPencil = new pencil({startWidth: 40, endWidth: 90, iterations: irisSize*50, nib: 'oval', nibOption: irisSizeY, color: hairColor, alpha: 0.1})
        let irisLine = new line({x:eyeX, y:eyeY, cp1:0, cp2:-10, endX:0, endY:5, cp3:0, cp4:0})
        drawLine(irisLine, irisPencil, irisContainer)
        //set the anchor point to the center of the sprite
        //irisContainer.pivot.set(0.5, 0.5);
        //irisContainer.angle = rand(-10, 10)
        eyeContainer.addChild(irisContainer);


        pupilX = eyeX + rand(-5, 5)
        pupilY = eyeY + rand(0, 10)

        pupilSize = rand(4, 7)

        let pupilPencil = new pencil({startWidth: pupilSize, endWidth: 2, iterations: pupilSize*50, nib: 'circle', color: multiplyColor, alpha: 0.1})
        let pupilLine = new line({x:pupilX, y:pupilY, cp1:0, cp2:-5, endX:0, endY:1, cp3:0, cp4:0})
        drawLine(pupilLine, pupilPencil, eyeContainer)

        
        app.stage.addChild(eyeContainer);

        
        /*



        //Pupil
        pupilX = eyeX + rand(-5, 5)
        pupilY = eyeY + rand(0, 10)

        pupilSize = rand(4, 10)
        pupilShineOffsetX = rand(-20, 20)
        pupilShineOffsetY = rand(-20, 20)
        pupilShineEnd = rand(0, 10)

        eyeShineTrue = rand(0, 1)
        eyeShineTwoTrue = rand(0, 1)
        if(eyeShineTrue > 0.5) {
            pencilTo(pupilSize*2, 2, pupilSize*10, '#FFFFFF', pupilX-pupilShineOffsetX, pupilY-pupilShineOffsetY, pupilShineEnd, 0, 0, -10, 0, 10, 0, 1)
        }
        if(eyeShineTwoTrue > 0.8) {
            pencilTo(pupilSize*4, 2, pupilSize*20, '#FFFFFF', pupilX+pupilShineOffsetX, pupilY+pupilShineOffsetY, pupilShineEnd, 0, 0, -10, 0, 10, 0, 1)
        }
        pencilTo(pupilSize, 2, pupilSize*40, multiplyColor, pupilX, pupilY, 0, 0, 0, -10, 0, 10, 0, 1)


        eyeBorderThickness = rand(1, 3)
        eyeBorderIterations = eyeBorderThickness * rand(5, 10)

        //Top to Right
        pencilTo(eyeBorderThickness, eyeBorderThickness/2, eyeBorderIterations, highlightColor, eyeX, eyeY - irisSizeY, irisSize, irisSizeY, 0, 0, irisSize, 0, 0.2, 1)
        pencilTo(eyeBorderThickness/2, eyeBorderThickness/4, eyeBorderIterations, highlightColor, eyeX + irisSize, eyeY, -irisSize, irisSizeY, 0, 0, 0, irisSizeY, 0.2, 1)
        pencilTo(eyeBorderThickness/4, eyeBorderThickness/2, eyeBorderIterations, highlightColor, eyeX, eyeY + irisSizeY, -irisSize, -irisSizeY, 0, 0, -irisSize, 0, 0.2, 1)
        pencilTo(eyeBorderThickness/2, eyeBorderThickness, eyeBorderIterations, highlightColor, eyeX - irisSize, eyeY, irisSize, -irisSizeY, 0, 0, 0, -irisSizeY, 0.2, 1)




        var eyeMaskContainer = new PIXI.Container()


        tearDuctX = eyeX + 70
        tearDuctY = eyeY + 30
        
        tearDuctDrawEndX = -130
        tearDuctDrawEndY = -50
        
        tearDuctDrawEndX2 = tearDuctX + tearDuctDrawEndX
        tearDuctDrawEndY2 = tearDuctY + tearDuctDrawEndY

        bezierX = -30
        bezierY = -100

        var shape = new PIXI.Graphics();
        shape.beginFill(0xaabbaa);
        shape.moveTo(tearDuctX, tearDuctY);
        shape.bezierCurveTo(tearDuctX, tearDuctY, tearDuctX + bezierX, tearDuctY + bezierY, tearDuctDrawEndX2, tearDuctDrawEndY2);
        eyeMaskContainer.addChild(shape);


        pencilTo(0, 15, 200, highlightColor, tearDuctX, tearDuctY, tearDuctDrawEndX - 10, tearDuctDrawEndY + 7, 0, 0, bezierX, bezierY, 0, 1)
        pencilTo(0, 10, 10, highlightColor, tearDuctX, tearDuctY, tearDuctDrawEndX, tearDuctDrawEndY, 0, 0, bezierX, bezierY, 0, 1)


        tearDuctDrawEndX2 = tearDuctX + tearDuctDrawEndX
        tearDuctDrawEndY2 = tearDuctY + tearDuctDrawEndY

        bezierX = -120
        bezierY = 50
        
        var shape = new PIXI.Graphics();
        shape.beginFill(0xaabbaa);
        shape.moveTo(tearDuctX, tearDuctY);
        shape.bezierCurveTo(tearDuctX, tearDuctY, tearDuctX + bezierX, tearDuctY + bezierY, tearDuctDrawEndX2, tearDuctDrawEndY2);


        eyeMaskContainer.addChild(shape);

        pencilTo(0, 5, 5, highlightColor, tearDuctX, tearDuctY, tearDuctDrawEndX, tearDuctDrawEndY, 0, 0, bezierX, bezierY, 0, 1)


        
        
        //app.stage.addChild(square);

        eyeContainer.mask = eyeMaskContainer;

        app.stage.addChild(eyeContainer)

        //pencilTo(5, 20, 5, '#000000', 0, 0, 300, 300, 0, 0, 0, 0, 0, 1)
        

        

        


        var drawLeftHair = function() {
            var template = new PIXI.Graphics();
            if (counter == 1) {
                template.beginFill(hairColor2);
            } else {
                template.beginFill(hairColor1);
            }
            counter++




            template.drawCircle(0, 0, 15);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);



            var randEndX = rand(-200, 150)
            var randEndXP = rand(-200, 250)

            var randEndYP = rand(-50, 50)
            var randEndX1 = rand(-100, 100)

            var randEndXX = rand(0, 100)

            var width = 70
            var endWidth = 70

            var bezier = [{
                x: randEndX1,
                y: -100
            }, {
                x: 0,
                y: randEndYP
            }, {
                x: randEndXP,
                y: 350
            }, {
                x: randEndX,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 3

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    alpha = Math.abs(alpha)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    alpha = 1 - alpha



                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                


                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        container.addChild(duplicate)

                    }


                }

            }

            var containerTwo = new PIXI.ParticleContainer(500000);
            app.stage.addChild(containerTwo)


            var template = new PIXI.Graphics();

            if (counter2 == 1) {
                template.beginFill(hairColor3);
            } else {
                template.beginFill(hairColor4);
            }
            counter2++



            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            app.stage.addChild(template);




            var width = 100
            var endWidth = 100

            var bezier = [{
                x: randEndX1,
                y: -100
            }, {
                x: 0,
                y: 50
            }, {
                x: randEndXP,
                y: 350
            }, {
                x: randEndX - 30,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 20

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    alpha = 1


                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if (j > iterations * 0.70) {
                        offsetY = -drawWidth
                    }
                    if (j > iterations * 0.85) {
                        offsetY = drawWidth
                    }



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerTwo.addChild(duplicate)

                    }


                }

            }



            var template = new PIXI.Graphics();
            template.beginFill(hairColor5);
            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            app.stage.addChild(template);




            var width = rand(1, 3)
            var endWidth = width + 2;

            var bezier = [{
                x: randEndX1 + 110,
                y: -100
            }, {
                x: 100,
                y: 50
            }, {
                x: randEndXP + 90,
                y: 350
            }, {
                x: randEndX + 110,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 0 //rand(10, 20)

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    //alpha = 1


                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if (j > iterations * 0.70) {
                        offsetY = -drawWidth
                    }
                    if (j > iterations * 0.85) {
                        offsetY = drawWidth
                    }



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerTwo.addChild(duplicate)

                    }


                }

            }

            var template = new PIXI.Graphics();
            template.beginFill(hairColor5);
            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            app.stage.addChild(template);




            var width = 2
            var endWidth = 1;

            var bezier = [{
                x: randEndX1 + 110,
                y: -100
            }, {
                x: 100,
                y: 50
            }, {
                x: randEndXP + 90,
                y: 350
            }, {
                x: randEndX + 130,
                y: 450
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 5 //0//rand(10, 20)

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    if (alpha < 0.1) {
                        alpha = 0.1
                    }

                    alpha = 1


                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);

                    if (j > iterations * 0.70) {
                        offsetY = -drawWidth
                    }
                    if (j > iterations * 0.85) {
                        offsetY = drawWidth
                    }



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerTwo.addChild(duplicate)

                    }


                }

            }



        }

        //drawLeftHair();

        //drawLeftHair();


        var containerThree = new PIXI.ParticleContainer(500000);
        app.stage.addChild(containerThree)

        var drawLeftHairTwo = function() {


            //flick
            var template = new PIXI.Graphics();
            template.beginFill(hairColor2);
            template.drawCircle(0, 0, 0.5);
            template.endFill();
            var texture = app.renderer.generateTexture(template);
            var circle = new PIXI.Sprite(texture);

            var width = 3
            var endWidth = 0

            startX = rand(200, 300)
            OffX = rand(200, 300)

            randEndX = rand(250, 450)
            randEndY = rand(180, 350);

            randPointX = rand(150, 450)

            var bezier = [{
                x: startX,
                y: -100
            }, {
                x: OffX,
                y: -100
            }, {
                x: randPointX,
                y: 150
            }, {
                x: randEndX,
                y: randEndY
            }]

            var bezierPoints = findCBezPoints(bezier);

            var points = [null, null, null];

            var widthFactor = (width - endWidth) / bezierPoints.length

            var iterations = 20 //rand(10, 20)

            for (var j = 0; j < iterations; j++) {

                for (var i = 0; i < bezierPoints.length; i++) {

                    var drawWidth = width - (widthFactor * i)

                    var x = bezierPoints[i].x;
                    var y = bezierPoints[i].y;

                    points[0] = points[1];
                    points[1] = points[2];
                    points[2] = {
                        X: x,
                        Y: y
                    };

                    if (points[0] == null)
                        continue;

                    var p0 = points[0];
                    var p1 = points[1];
                    var p2 = points[2];

                    var x0 = (p0.X + p1.X) / 2;
                    var y0 = (p0.Y + p1.Y) / 2;

                    var alpha = perlin.get(x0, y0)

                    var radius = drawWidth

                    if (width == 1) {
                        radius = radius / 20
                    }

                    var offsetX = rand(-radius, radius);
                    var offsetY = rand(-radius, radius);



                    let circleRadius = radius * Math.sqrt(Math.random())
                    let theta = Math.random() * 2 * Math.PI

                    x0 = x0 + radius * Math.cos(theta)
                    y0 = y0 + radius * Math.sin(theta)


                    if (i > 1) {
                        let duplicate = new PIXI.Sprite(circle.texture);
                        duplicate.x = x0
                        duplicate.y = y0
                        duplicate.alpha = alpha
                        containerThree.addChild(duplicate)

                    }


                }

            }

        }

        var addHair = rand(0, 1)
        if (addHair) {
            //drawLeftHairTwo();
            //drawLeftHairTwo();
        }*/
    </script>
</body>

</html>