/* eslint-disable */
this.PIXI=this.PIXI||{},this.PIXI.smooth=this.PIXI.smooth||{},function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@pixi/math"),require("@pixi/core"),require("@pixi/constants"),require("@pixi/graphics"),require("@pixi/utils"),require("@pixi/display")):"function"==typeof define&&define.amd?define(["exports","@pixi/math","@pixi/core","@pixi/constants","@pixi/graphics","@pixi/utils","@pixi/display"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self)._pixi_graphics_smooth={},t.PIXI,t.PIXI,t.PIXI,t.PIXI,t.PIXI.utils,t.PIXI)}(this,(function(t,e,n,i,s,r,a){"use strict";function l(t,e,n=.001){return this===e||Math.abs(t.a-e.a)<n&&Math.abs(t.b-e.b)<n&&Math.abs(t.c-e.c)<n&&Math.abs(t.d-e.d)<n&&Math.abs(t.tx-e.tx)<n&&Math.abs(t.ty-e.ty)<n}class o{constructor(){this.textureIds=[],this.matrices=[],this.lines=[],this.count=0}clear(){for(let t=0;t<this.count;t++)this.textureIds[t]=null,this.matrices[t]=null;this.count=0}add(t,e,n,i,s,r){const{textureIds:a,matrices:o,lines:h,count:c}=this;t=4*t+s;for(let s=0;s<c;s++)if(h[2*s]===n&&h[2*s+1]===i&&a[s]===t&&l(o[s],e))return s;return c>=r.maxStyles?-1:(a[c]=t,o[c]=e,h[2*c]=n,h[2*c+1]=i,this.count++,c)}}class h{constructor(){this.texArray=new n.BatchTextureArray,this.styleArray=new o,this.shader=null,this.blend=i.BLEND_MODES.NORMAL,this.start=0,this.size=0,this.TICK=0,this.settings=null,this.data=null}clear(){this.texArray.clear(),this.styleArray.clear(),this.settings=null,this.data=null,this.shader=null}begin(t,e){this.TICK=++n.BaseTexture._globalBatch,this.settings=t,this.shader=e,this.start=0,this.size=0,this.data=null,e&&e.settings&&(this.settings=e.settings)}check(t){return 0===this.size?(this.shader=t,!0):this.shader===t}add(t,n,i,s,r){const{texArray:a,TICK:l,styleArray:o,settings:h}=this,{baseTexture:c}=t;if(c._batchEnabled!==l&&a.count===h.maxTextures)return-1;const u=c._batchEnabled!==l?a.count:c._batchLocation,p=o.add(u,n||e.Matrix.IDENTITY,i,s,r,h);return p>=0&&c._batchEnabled!==l&&(c._batchEnabled=l,c._batchLocation=a.count,a.elements[a.count++]=c),p}}class c{constructor(){this.reset()}begin(t,e,n){this.reset(),this.style=t,this.start=e,this.attribStart=n,this.jointEnd=0}end(t,e){this.attribSize=e-this.attribStart,this.size=t-this.start}reset(){this.style=null,this.size=0,this.start=0,this.attribStart=0,this.attribSize=0,this.styleId=-1,this.rgba=0,this.jointEnd=0}}class u{constructor(){this.reset()}toJSON(){return this.copyTo({})}clone(){return this.copyTo(new u)}copyTo(t){return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.shader=this.shader,t.visible=this.visible,t.smooth=this.smooth,t.matrixTex=null,t}packLineScale(){return 0}reset(){this.color=16777215,this.alpha=1,this.texture=n.Texture.WHITE,this.matrix=null,this.shader=null,this.visible=!1,this.smooth=!1,this.matrixTex=null}destroy(){this.texture=null,this.matrix=null,this.matrixTex=null}getTextureMatrix(){const t=this.texture;return this.matrix?t.frame.width===t.baseTexture.width&&t.frame.height===t.baseTexture.height?this.matrix:(this.matrixTex?this.matrixTex.copyFrom(this.matrix):this.matrixTex=this.matrix.clone(),this.matrixTex.translate(Number(t.frame.x),Number(t.frame.y)),this.matrixTex):null}}t.LINE_SCALE_MODE=void 0,function(t){t.NONE="none";t.NORMAL="normal";t.HORIZONTAL="horizontal";t.VERTICAL="vertical"}(t.LINE_SCALE_MODE||(t.LINE_SCALE_MODE={}));class p extends u{clone(){return this.copyTo(new p)}copyTo(t){return t.color=this.color,t.alpha=this.alpha,t.texture=this.texture,t.matrix=this.matrix,t.shader=this.shader,t.visible=this.visible,t.width=this.width,t.alignment=this.alignment,t.cap=this.cap,t.join=this.join,t.miterLimit=this.miterLimit,t.scaleMode=this.scaleMode,t}packLineScale(){switch(this.scaleMode){case t.LINE_SCALE_MODE.NORMAL:return 1;case t.LINE_SCALE_MODE.HORIZONTAL:return 2;case t.LINE_SCALE_MODE.VERTICAL:return 3;default:return 0}}reset(){super.reset(),this.smooth=!0,this.color=0,this.width=0,this.alignment=.5,this.cap=s.LINE_CAP.BUTT,this.join=s.LINE_JOIN.MITER,this.miterLimit=10,this.scaleMode=t.LINE_SCALE_MODE.NORMAL}}class d{constructor(){d.prototype.__init.call(this),d.prototype.__init2.call(this),d.prototype.__init3.call(this),d.prototype.__init4.call(this),d.prototype.__init5.call(this)}__init(){this.verts=[]}__init2(){this.joints=[]}__init3(){this.vertexSize=0}__init4(){this.indexSize=0}__init5(){this.closePointEps=1e-4}clear(){this.verts.length=0,this.joints.length=0,this.vertexSize=0,this.indexSize=0}destroy(){this.verts.length=0,this.joints.length=0}}t.JOINT_TYPE=void 0,function(t){t[t.NONE=0]="NONE";t[t.FILL=1]="FILL";t[t.JOINT_BEVEL=4]="JOINT_BEVEL";t[t.JOINT_MITER=8]="JOINT_MITER";t[t.JOINT_ROUND=12]="JOINT_ROUND";t[t.JOINT_CAP_BUTT=16]="JOINT_CAP_BUTT";t[t.JOINT_CAP_SQUARE=18]="JOINT_CAP_SQUARE";t[t.JOINT_CAP_ROUND=20]="JOINT_CAP_ROUND";t[t.FILL_EXPAND=24]="FILL_EXPAND";t[t.CAP_BUTT=32]="CAP_BUTT";t[t.CAP_SQUARE=64]="CAP_SQUARE";t[t.CAP_ROUND=96]="CAP_ROUND";t[t.CAP_BUTT2=128]="CAP_BUTT2"}(t.JOINT_TYPE||(t.JOINT_TYPE={}));class f{constructor(){f.prototype.__init.call(this),f.prototype.__init2.call(this),f.prototype.__init3.call(this)}static __initStatic(){this.vertsByJoint=[]}__init(){this.strideFloats=12}updateBufferSize(e,n,i,s){const{joints:r}=s;let a=!1,l=0,o=0;for(let i=e;i<e+n;i++){const e=-32&r[i],n=31&r[i];if(n===t.JOINT_TYPE.FILL){a=!0,l++;continue}if(n>=t.JOINT_TYPE.FILL_EXPAND){l+=3,o+=3;continue}const s=f.vertsByJoint[n]+f.vertsByJoint[e];s>=4&&(l+=s,o+=6+3*Math.max(s-6,0))}a&&(o+=i),s.vertexSize+=l,s.indexSize+=o}__init2(){this.bufferPos=0}__init3(){this.indexPos=0}beginPack(t,e,n,i,s=0,r=0){this.buildData=t,this.bufFloat=e,this.bufUint=n,this.indices=i,this.bufferPos=s,this.indexPos=r}endPack(){this.buildData=null,this.bufFloat=null,this.bufUint=null,this.indices=null}packInterleavedGeometry(e,n,i,s,r){const{bufFloat:a,bufUint:l,indices:o,buildData:h,strideFloats:c}=this,{joints:u,verts:p}=h;let d,y,_,T,x,v,m,g,E=this.bufferPos,I=this.indexPos,N=this.bufferPos/this.strideFloats,P=!1,b=0;for(let i=e;i<e+n;i++){const e=u[i],n=-32&u[i],h=31&u[i];if(h===t.JOINT_TYPE.FILL){P=!0,d=p[2*i],y=p[2*i+1],a[E]=d,a[E+1]=y,a[E+2]=d,a[E+3]=y,a[E+4]=d,a[E+5]=y,a[E+6]=d,a[E+7]=y,a[E+8]=b,a[E+9]=16*h,a[E+10]=s,l[E+11]=r,E+=c;continue}if(h>=t.JOINT_TYPE.FILL_EXPAND){x=p[2*i],v=p[2*i+1],d=p[2*i+2],y=p[2*i+3],_=p[2*i+4],T=p[2*i+5];const t=i+3;for(let n=0;n<3;n++)a[E]=x,a[E+1]=v,a[E+2]=d,a[E+3]=y,a[E+4]=_,a[E+5]=T,a[E+6]=p[2*(t+n)],a[E+7]=p[2*(t+n)+1],a[E+8]=b,a[E+9]=16*e+n,a[E+10]=s,l[E+11]=r,E+=c;o[I]=N,o[I+1]=N+1,o[I+2]=N+2,I+=3,N+=3;continue}const L=f.vertsByJoint[h]+f.vertsByJoint[n];if(0===L)continue;d=p[2*i],y=p[2*i+1],_=p[2*i+2],T=p[2*i+3],x=p[2*i-2],v=p[2*i-1];const S=Math.sqrt((_-d)*(_-d)+(T-y)*(T-y));0===f.vertsByJoint[h]&&(b-=S),(-3&h)!==t.JOINT_TYPE.JOINT_CAP_BUTT?(m=p[2*i+4],g=p[2*i+5]):(m=d,g=y);for(let t=0;t<L;t++)a[E]=x,a[E+1]=v,a[E+2]=d,a[E+3]=y,a[E+4]=_,a[E+5]=T,a[E+6]=m,a[E+7]=g,a[E+8]=b,a[E+9]=16*e+t,a[E+10]=s,l[E+11]=r,E+=c;b+=S,o[I]=N,o[I+1]=N+1,o[I+2]=N+2,o[I+3]=N,o[I+4]=N+2,o[I+5]=N+3,I+=6;for(let t=5;t+1<L;t++)o[I]=N+4,o[I+1]=N+t,o[I+2]=N+t+1,I+=3;N+=L}if(P){for(let t=0;t<i.length;t++)o[I+t]=i[t]+N;I+=i.length}this.bufferPos=E,this.indexPos=I}}f.__initStatic();const y=f.vertsByJoint;for(let t=0;t<256;t++)y.push(0);y[t.JOINT_TYPE.FILL]=1;for(let e=0;e<8;e++)y[t.JOINT_TYPE.FILL_EXPAND+e]=3;y[t.JOINT_TYPE.JOINT_BEVEL]=9,y[t.JOINT_TYPE.JOINT_BEVEL+1]=9,y[t.JOINT_TYPE.JOINT_BEVEL+2]=9,y[t.JOINT_TYPE.JOINT_BEVEL+3]=9,y[t.JOINT_TYPE.JOINT_ROUND]=9,y[t.JOINT_TYPE.JOINT_ROUND+1]=9,y[t.JOINT_TYPE.JOINT_ROUND+2]=9,y[t.JOINT_TYPE.JOINT_ROUND+3]=9,y[t.JOINT_TYPE.JOINT_MITER]=9,y[t.JOINT_TYPE.JOINT_MITER+1]=9,y[t.JOINT_TYPE.JOINT_MITER+2]=4,y[t.JOINT_TYPE.JOINT_MITER+3]=4,y[t.JOINT_TYPE.JOINT_CAP_BUTT]=4,y[t.JOINT_TYPE.JOINT_CAP_BUTT+1]=4,y[t.JOINT_TYPE.JOINT_CAP_SQUARE]=4,y[t.JOINT_TYPE.JOINT_CAP_SQUARE+1]=4,y[t.JOINT_TYPE.JOINT_CAP_ROUND]=9,y[t.JOINT_TYPE.JOINT_CAP_ROUND+1]=9,y[t.JOINT_TYPE.CAP_ROUND]=4;class _{constructor(t,e=null,n=null,i=null){this.shape=t,this.lineStyle=n,this.fillStyle=e,this.matrix=i,this.type=t.type,this.points=[],this.holes=[],this.triangles=[],this.closeStroke=!1,this.clearBuild()}clearPath(){this.points.length=0,this.closeStroke=!0}clearBuild(){this.triangles.length=0,this.fillStart=0,this.fillLen=0,this.strokeStart=0,this.strokeLen=0,this.fillAA=!1}clone(){return new _(this.shape,this.fillStyle,this.lineStyle,this.matrix)}capType(){let e;switch(this.lineStyle.cap){case s.LINE_CAP.SQUARE:e=t.JOINT_TYPE.CAP_SQUARE;break;case s.LINE_CAP.ROUND:e=t.JOINT_TYPE.CAP_ROUND;break;default:e=t.JOINT_TYPE.CAP_BUTT}return e}goodJointType(){let e;switch(this.lineStyle.join){case s.LINE_JOIN.BEVEL:e=t.JOINT_TYPE.JOINT_BEVEL;break;case s.LINE_JOIN.ROUND:e=t.JOINT_TYPE.JOINT_ROUND;break;default:e=t.JOINT_TYPE.JOINT_MITER+3}return e}jointType(){let e;switch(this.lineStyle.join){case s.LINE_JOIN.BEVEL:e=t.JOINT_TYPE.JOINT_BEVEL;break;case s.LINE_JOIN.ROUND:e=t.JOINT_TYPE.JOINT_ROUND;break;default:e=t.JOINT_TYPE.JOINT_MITER}return e}destroy(){this.shape=null,this.holes.length=0,this.holes=null,this.points.length=0,this.points=null,this.lineStyle=null,this.fillStyle=null,this.triangles=null}}class T{path(t,n){const i=t.points;let s,r,a,l,o,h;if(t.type===e.SHAPES.CIRC){const e=t.shape;s=e.x,r=e.y,o=h=e.radius,a=l=0}else if(t.type===e.SHAPES.ELIP){const e=t.shape;s=e.x,r=e.y,o=e.width,h=e.height,a=l=0}else{const e=t.shape,n=e.width/2,i=e.height/2;s=e.x+n,r=e.y+i,o=h=Math.max(0,Math.min(e.radius,Math.min(n,i))),a=n-o,l=i-h}if(!(o>=0&&h>=0&&a>=0&&l>=0))return void(i.length=0);const c=Math.ceil(2.3*Math.sqrt(o+h)),u=8*c+(a?4:0)+(l?4:0);if(i.length=u,0===u)return;if(0===c)return i.length=8,i[0]=i[6]=s+a,i[1]=i[3]=r+l,i[2]=i[4]=s-a,void(i[5]=i[7]=r-l);let p=0,d=4*c+(a?2:0)+2,f=d,y=u;{const t=a+o,e=l,n=s+t,h=s-t,c=r+e;if(i[p++]=n,i[p++]=c,i[--d]=c,i[--d]=h,l){const t=r-e;i[f++]=h,i[f++]=t,i[--y]=t,i[--y]=n}}for(let t=1;t<c;t++){const e=Math.PI/2*(t/c),n=a+Math.cos(e)*o,u=l+Math.sin(e)*h,_=s+n,T=s-n,x=r+u,v=r-u;i[p++]=_,i[p++]=x,i[--d]=x,i[--d]=T,i[f++]=T,i[f++]=v,i[--y]=v,i[--y]=_}{const t=l+h,e=s+a,n=s-a,o=r+t,c=r-t;i[p++]=e,i[p++]=o,i[--y]=c,i[--y]=e,a&&(i[p++]=n,i[p++]=o,i[--y]=c,i[--y]=n)}}fill(n,i){const{verts:s,joints:r}=i,{points:a,triangles:l}=n;if(0===a.length)return;let o,h;if(n.type!==e.SHAPES.RREC){const t=n.shape;o=t.x,h=t.y}else{const t=n.shape;o=t.x+t.width/2,h=t.y+t.height/2}const c=n.matrix,u=c?c.a*o+c.c*h+c.tx:o,p=c?c.b*o+c.d*h+c.ty:h;let d=1;if(!n.fillAA){s.push(u,p),r.push(t.JOINT_TYPE.FILL),s.push(a[0],a[1]),r.push(t.JOINT_TYPE.FILL);for(let e=2;e<a.length;e+=2)s.push(a[e],a[e+1]),r.push(t.JOINT_TYPE.FILL),l.push(d++,0,d);return void l.push(1,0,d)}const f=a.length;let y=a[f-2],_=a[f-1],T=_-a[f-3],x=a[f-4]-y;const v=Math.sqrt(T*T+x*x);let m,g;T/=v,x/=v;for(let e=0;e<f;e+=2){const n=a[e],i=a[e+1];let l=i-_,o=y-n;const h=Math.sqrt(l*l+o*o);l/=h,o/=h;let c=T+l,d=x+o;const f=l*c+o*d;c/=f,d/=f,e>0?(s.push(c),s.push(d)):(m=c,g=d),s.push(u),s.push(p),s.push(y),s.push(_),s.push(n),s.push(i),s.push(0),s.push(0),s.push(c),s.push(d),r.push(t.JOINT_TYPE.FILL_EXPAND+2),r.push(t.JOINT_TYPE.NONE),r.push(t.JOINT_TYPE.NONE),r.push(t.JOINT_TYPE.NONE),r.push(t.JOINT_TYPE.NONE),r.push(t.JOINT_TYPE.NONE),y=n,_=i,T=l,x=o}s.push(m),s.push(g)}line(e,n){const{verts:i,joints:s}=n,{points:r}=e,a=8===r.length?e.goodJointType():t.JOINT_TYPE.JOINT_MITER+3,l=r.length;if(0!==l){i.push(r[l-2],r[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(r[t],r[t+1]),s.push(a);i.push(r[0],r[1]),s.push(t.JOINT_TYPE.NONE),i.push(r[2],r[3]),s.push(t.JOINT_TYPE.NONE)}}}const x=[];function v(t,e=!1){const n=t.length;if(n<6)return;let i=0;for(let e=0,s=t[n-2],r=t[n-1];e<n;e+=2){const n=t[e],a=t[e+1];i+=(n-s)*(a+r),s=n,r=a}if(!e&&i>0||e&&i<=0){const e=n/2;for(let i=e+e%2;i<n;i+=2){const e=n-i-2,s=n-i-1,r=i,a=i+1;[t[e],t[r]]=[t[r],t[e]],[t[s],t[a]]=[t[a],t[s]]}}}class m{path(t,n){const i=t.shape,s=t.points=i.points.slice(),r=n.closePointEps,a=r*r;if(0===s.length)return;const l=new e.Point(s[0],s[1]),o=new e.Point(s[s.length-2],s[s.length-1]),h=t.closeStroke=i.closeStroke;let c=s.length,u=2;for(let t=2;t<c;t+=2){const e=s[t-2],n=s[t-1],i=s[t],a=s[t+1];let l=!0;Math.abs(e-i)<r&&Math.abs(n-a)<r&&(l=!1),l&&(s[u]=s[t],s[u+1]=s[t+1],u+=2)}s.length=c=u,u=2;for(let t=2;t+2<c;t+=2){let e=s[t-2],n=s[t-1];const i=s[t],r=s[t+1];let l=s[t+2],o=s[t+3];e-=i,n-=r,l-=i,o-=r;let h=!0;Math.abs(l*n-o*e)<a&&e*l+n*o<-a&&(h=!1),h&&(s[u]=s[t],s[u+1]=s[t+1],u+=2)}if(s[u]=s[c-2],s[u+1]=s[c-1],u+=2,s.length=c=u,!(c<=2)&&h){Math.abs(l.x-o.x)<r&&Math.abs(l.y-o.y)<r&&(s.pop(),s.pop())}}line(e,n){const{closeStroke:i,points:s}=e,r=s.length;if(r<=2)return;const{verts:a,joints:l}=n,o=e.jointType(),h=e.capType();let c,u,p=0;i?(c=s[r-2],u=s[r-1],l.push(t.JOINT_TYPE.NONE)):(c=s[2],u=s[3],h===t.JOINT_TYPE.CAP_ROUND?(a.push(s[0],s[1]),l.push(t.JOINT_TYPE.NONE),l.push(t.JOINT_TYPE.CAP_ROUND),p=0):(p=h,l.push(t.JOINT_TYPE.NONE))),a.push(c,u);for(let e=0;e<r;e+=2){const n=s[e],d=s[e+1];let f=o;e+2>=r?i||(f=t.JOINT_TYPE.NONE):e+4>=r&&(i||(h===t.JOINT_TYPE.CAP_ROUND&&(f=t.JOINT_TYPE.JOINT_CAP_ROUND),h===t.JOINT_TYPE.CAP_BUTT&&(f=t.JOINT_TYPE.JOINT_CAP_BUTT),h===t.JOINT_TYPE.CAP_SQUARE&&(f=t.JOINT_TYPE.JOINT_CAP_SQUARE))),f+=p,p=0,a.push(n,d),l.push(f),c=n,u=d}i?(a.push(s[0],s[1]),l.push(t.JOINT_TYPE.NONE),a.push(s[2],s[3]),l.push(t.JOINT_TYPE.NONE)):(a.push(s[r-4],s[r-3]),l.push(t.JOINT_TYPE.NONE))}fill(e,n){let i=e.points;const s=e.holes,a=n.closePointEps,{verts:l,joints:o}=n;if(i.length<6)return;const h=[];let c=i.length;v(i,!1);for(let t=0;t<s.length;t++){const e=s[t];v(e.points,!0),h.push(i.length/2),i=i.concat(e.points)}const u=x;u.length<i.length&&(u.length=i.length);let p=0;for(let t=0;t<=h.length;t++){let e=c/2;t>0&&(e=t<h.length?h[t]:i.length>>1),u[2*p]=e-1,u[2*(e-1)+1]=p;for(let t=p;t+1<e;t++)u[2*t+1]=t+1,u[2*t+2]=t;p=e}if(e.triangles=r.earcut(i,h,2),!e.triangles)return;if(!e.fillAA){for(let e=0;e<i.length;e+=2)l.push(i[e],i[e+1]),o.push(t.JOINT_TYPE.FILL);return}const{triangles:d}=e;c=i.length;for(let e=0;e<d.length;e+=3){let n=0;for(let t=0;t<3;t++){const i=d[e+t],s=d[e+(t+1)%3];u[2*i]!==s&&u[2*i+1]!==s||(n|=1<<t)}o.push(t.JOINT_TYPE.FILL_EXPAND+n),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE),o.push(t.JOINT_TYPE.NONE)}for(let t=0;t<c/2;t++){const e=u[2*t],n=u[2*t+1];let s=i[2*n+1]-i[2*t+1],r=-(i[2*n]-i[2*t]),l=i[2*t+1]-i[2*e+1],o=-(i[2*t]-i[2*e]);const h=Math.sqrt(s*s+r*r);s/=h,r/=h;const c=Math.sqrt(l*l+o*o);l/=c,o/=c;let p=s+l,d=r+o;const f=p*s+d*r;Math.abs(f)<a?(p=s,d=r):(p/=f,d/=f),u[2*t]=p,u[2*t+1]=d}for(let t=0;t<d.length;t+=3){const e=d[t],n=d[t+1],s=d[t+2],r=i[2*s+1]-i[2*n+1],a=-(i[2*s]-i[2*n]),o=i[2*n+1]-i[2*e+1];let h=1;r*-(i[2*n]-i[2*e])-o*a>0&&(h=2);for(let e=0;e<3;e++){const n=d[t+e*h%3];l.push(i[2*n],i[2*n+1])}for(let e=0;e<3;e++){const n=d[t+e*h%3];l.push(u[2*n],u[2*n+1])}}}}class g{constructor(){g.prototype.__init.call(this)}__init(){this._polyBuilder=new m}path(t,e){const n=t.shape,i=n.x,s=n.y,r=n.width,a=n.height,l=t.points;l.length=0,l.push(i,s,i+r,s,i+r,s+a,i,s+a)}line(e,n){const{verts:i,joints:s}=n,{points:r}=e,a=e.goodJointType(),l=r.length;i.push(r[l-2],r[l-1]),s.push(t.JOINT_TYPE.NONE);for(let t=0;t<l;t+=2)i.push(r[t],r[t+1]),s.push(a);i.push(r[0],r[1]),s.push(t.JOINT_TYPE.NONE),i.push(r[2],r[3]),s.push(t.JOINT_TYPE.NONE)}fill(e,n){const{verts:i,joints:s}=n,{points:r,triangles:a}=e;if(a.length=0,!e.fillAA)return i.push(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7]),s.push(t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL,t.JOINT_TYPE.FILL),void a.push(0,1,2,0,2,3);this._polyBuilder.fill(e,n)}}function E(t,e,n){return t+(e-t)*n}function I(t,e,n,i,s,r,a=[],l=.001){const o=a;let h=0,c=0,u=0,p=0,d=0,f=0;for(let a=0,y=0;a<=20;++a)y=a/20,h=E(t,n,y),c=E(e,i,y),u=E(n,s,y),p=E(i,r,y),d=E(h,u,y),f=E(c,p,y),0===a&&Math.abs(d-o[o.length-2])<l&&Math.abs(f-o[o.length-1])<l||o.push(d,f);return o}class N{constructor(){N.prototype.__init.call(this)}__init(){this._circleBuilder=new T}path(t,e){if(s.Graphics.nextRoundedRectBehavior)return void this._circleBuilder.path(t,e);const n=t.shape,{points:i}=t,r=n.x,a=n.y,l=n.width,o=n.height,h=Math.max(0,Math.min(n.radius,Math.min(l,o)/2));if(i.length=0,h){const t=e.closePointEps;I(r,a+h,r,a,r+h,a,i,t),I(r+l-h,a,r+l,a,r+l,a+h,i,t),I(r+l,a+o-h,r+l,a+o,r+l-h,a+o,i,t),I(r+h,a+o,r,a+o,r,a+o-h,i,t),i.length>=4&&Math.abs(i[0]-i[i.length-2])<t&&Math.abs(i[1]-i[i.length-1])<t&&(i.pop(),i.pop())}else i.push(r,a,r+l,a,r+l,a+o,r,a+o)}line(t,e){this._circleBuilder.line(t,e)}fill(t,e){this._circleBuilder.fill(t,e)}}const P={[e.SHAPES.POLY]:new m,[e.SHAPES.CIRC]:new T,[e.SHAPES.ELIP]:new T,[e.SHAPES.RECT]:new g,[e.SHAPES.RREC]:new N},b=[],L=[],S=new e.Point,O=new a.Bounds;class A extends n.Geometry{static __initStatic(){this.BATCHABLE_SIZE=100}__init(){this.indicesUint16=null}get points(){return this.buildData.verts}get closePointEps(){return this.buildData.closePointEps}initAttributes(t){this._buffer=new n.Buffer(null,t,!1),this._bufferFloats=new Float32Array,this._bufferUint=new Uint32Array,this._indexBuffer=new n.Buffer(null,t,!0),this.addAttribute("aPrev",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aPoint1",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aPoint2",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aNext",this._buffer,2,!1,i.TYPES.FLOAT).addAttribute("aTravel",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aVertexJoint",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aStyleId",this._buffer,1,!1,i.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,i.TYPES.UNSIGNED_BYTE).addIndex(this._indexBuffer),this.strideFloats=12}constructor(){super(),A.prototype.__init.call(this),this.initAttributes(!1),this.buildData=new d,this.graphicsData=[],this.dirty=0,this.batchDirty=-1,this.cacheDirty=-1,this.clearDirty=0,this.drawCalls=[],this.batches=[],this.shapeBuildIndex=0,this.shapeBatchIndex=0,this._bounds=new a.Bounds,this.boundsDirty=-1,this.boundsPadding=0,this.batchable=!1,this.indicesUint16=null,this.packer=null,this.packSize=0,this.pack32index=null}checkInstancing(t,e){this.packer||(this.packer=new f,this.pack32index=e)}get bounds(){return this.boundsDirty!==this.dirty&&(this.boundsDirty=this.dirty,this.calculateBounds()),this._bounds}invalidate(){this.boundsDirty=-1,this.dirty++,this.batchDirty++,this.shapeBuildIndex=0,this.shapeBatchIndex=0,this.packSize=0,this.buildData.clear();for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].clear(),L.push(this.drawCalls[t]);this.drawCalls.length=0;for(let t=0;t<this.batches.length;t++){const e=this.batches[t];e.reset(),b.push(e)}this.batches.length=0}clear(){return this.graphicsData.length>0&&(this.invalidate(),this.clearDirty++,this.graphicsData.length=0),this}drawShape(t,e=null,n=null,i=null){const s=new _(t,e,n,i);return this.graphicsData.push(s),this.dirty++,this}drawHole(t,e=null){if(!this.graphicsData.length)return null;const n=new _(t,null,null,e),i=this.graphicsData[this.graphicsData.length-1];return n.lineStyle=i.lineStyle,i.holes.push(n),this.dirty++,this}destroy(){super.destroy();for(let t=0;t<this.graphicsData.length;++t)this.graphicsData[t].destroy();this.buildData.destroy(),this.buildData=null,this.indexBuffer.destroy(),this.indexBuffer=null,this.graphicsData.length=0,this.graphicsData=null,this.drawCalls.length=0,this.drawCalls=null,this.batches.length=0,this.batches=null,this._bounds=null}containsPoint(t){const e=this.graphicsData;for(let n=0;n<e.length;++n){const i=e[n];if(i.fillStyle.visible&&(i.shape&&(i.matrix?i.matrix.applyInverse(t,S):S.copyFrom(t),i.shape.contains(S.x,S.y)))){let t=!1;if(i.holes)for(let e=0;e<i.holes.length;e++){if(i.holes[e].shape.contains(S.x,S.y)){t=!0;break}}if(!t)return!0}}return!1}updatePoints(){}updateBufferSize(){this._buffer.update(new Float32Array)}updateBuild(){const{graphicsData:t,buildData:i}=this,s=t.length;for(let r=this.shapeBuildIndex;r<s;r++){const s=t[r];s.strokeStart=0,s.strokeLen=0,s.fillStart=0,s.fillLen=0;const{fillStyle:a,lineStyle:l,holes:o}=s;if(!a.visible&&!l.visible)continue;const h=P[s.type];if(s.clearPath(),h.path(s,i),s.matrix&&this.transformPoints(s.points,s.matrix),s.clearBuild(),!(s.points.length<=2)&&((a.visible||l.visible)&&this.processHoles(o),a.visible&&(s.fillAA=s.fillStyle.smooth&&s.fillStyle.texture===n.Texture.WHITE&&0===o.length&&!(s.closeStroke&&s.lineStyle.visible&&!s.lineStyle.shader&&s.lineStyle.alpha>=.99&&s.lineStyle.width*Math.min(s.lineStyle.alignment,1-s.lineStyle.alignment)>=.495),s.fillStart=i.joints.length,o.length?P[e.SHAPES.POLY].fill(s,i):h.fill(s,i),s.fillLen=i.joints.length-s.fillStart),l.visible)){s.strokeStart=i.joints.length,h.line(s,i);for(let t=0;t<o.length;t++){const e=o[t];P[e.type].line(e,i)}s.strokeLen=i.joints.length-s.strokeStart}}this.shapeBuildIndex=s}updateBatches(t){if(!this.graphicsData.length)return void(this.batchable=!0);if(this.updateBuild(),!this.validateBatching())return;const{buildData:e,graphicsData:n}=this,s=n.length;this.cacheDirty=this.dirty;let r=null,a=null;this.batches.length>0&&(r=this.batches[this.batches.length-1],a=r.style);for(let t=this.shapeBatchIndex;t<s;t++){const s=n[t],l=s.fillStyle,o=s.lineStyle;if(s.matrix&&this.transformPoints(s.points,s.matrix),l.visible||o.visible)for(let t=0;t<2;t++){const n=0===t?l:o;if(!n.visible)continue;const h=n.texture.baseTexture,u=e.vertexSize,p=e.indexSize;h.wrapMode=i.WRAP_MODES.REPEAT,0===t?this.packer.updateBufferSize(s.fillStart,s.fillLen,s.triangles.length,e):this.packer.updateBufferSize(s.strokeStart,s.strokeLen,s.triangles.length,e);e.vertexSize!==u&&(r&&!this._compareStyles(a,n)&&(r.end(p,u),r=null),r||(r=b.pop()||new c,r.begin(n,p,u),this.batches.push(r),a=n),r.jointEnd=0===t?s.fillStart+s.fillLen:s.strokeStart+s.strokeLen)}}this.shapeBatchIndex=s,r&&r.end(e.indexSize,e.vertexSize),0!==this.batches.length?(this.batchable=this.isBatchable(),this.batchable?this.packBatches():(this.buildDrawCalls(t),this.updatePack())):this.batchable=!0}updatePack(){const{vertexSize:t,indexSize:e}=this.buildData;if(this.packSize===t)return;const{strideFloats:n,packer:i,buildData:s,batches:r}=this,a=this._buffer,l=this._indexBuffer,o=t*n;if(a.data.length!==o){const t=new ArrayBuffer(4*o);this._bufferFloats=new Float32Array(t),this._bufferUint=new Uint32Array(t),a.data=this._bufferFloats}l.data.length!==e&&(t>65535&&this.pack32index?l.data=new Uint32Array(e):l.data=new Uint16Array(e)),i.beginPack(s,this._bufferFloats,this._bufferUint,l.data);let h=0;for(let t=0;t<this.graphicsData.length;t++){const e=this.graphicsData[t];if(e.fillLen){for(;r[h].jointEnd<=e.fillStart;)h++;i.packInterleavedGeometry(e.fillStart,e.fillLen,e.triangles,r[h].styleId,r[h].rgba)}if(e.strokeLen){for(;r[h].jointEnd<=e.strokeStart;)h++;i.packInterleavedGeometry(e.strokeStart,e.strokeLen,e.triangles,r[h].styleId,r[h].rgba)}}a.update(),l.update(),this.packSize=t}_compareStyles(t,n){if(!t||!n)return!1;if(t.texture.baseTexture!==n.texture.baseTexture)return!1;if(t.color+t.alpha!==n.color+n.alpha)return!1;if(t.width!==n.width)return!1;if(t.scaleMode!==n.scaleMode)return!1;if(t.alignment!==n.alignment)return!1;return l(t.matrix||e.Matrix.IDENTITY,n.matrix||e.Matrix.IDENTITY)}validateBatching(){if(this.dirty===this.cacheDirty||!this.graphicsData.length)return!1;for(let t=0,e=this.graphicsData.length;t<e;t++){const e=this.graphicsData[t],n=e.fillStyle,i=e.lineStyle;if(n&&!n.texture.baseTexture.valid)return!1;if(i&&!i.texture.baseTexture.valid)return!1}return!0}packBatches(){this.batchDirty++;const t=this.batches;for(let e=0,n=t.length;e<n;e++){const n=t[e];for(let t=0;t<n.size;t++){const e=n.start+t;this.indicesUint16[e]=this.indicesUint16[e]-n.attribStart}}}isBatchable(){return!1}buildDrawCalls(t){for(let t=0;t<this.drawCalls.length;t++)this.drawCalls[t].clear(),L.push(this.drawCalls[t]);this.drawCalls.length=0;let e=L.pop()||new h;e.begin(t,null);let n=0;this.drawCalls.push(e);for(let i=0;i<this.batches.length;i++){const s=this.batches[i],a=s.style;if(0===s.attribSize)continue;let l=-1;const o=a.getTextureMatrix();e.check(a.shader)&&(l=e.add(a.texture,o,a.width,a.alignment||0,a.packLineScale())),l<0&&(e=L.pop()||new h,this.drawCalls.push(e),e.begin(t,a.shader),e.start=n,l=e.add(a.texture,o,a.width,a.alignment||0,a.packLineScale())),e.size+=s.size,n+=s.size;const{color:c,alpha:u}=a,p=(c>>16)+(65280&c)+((255&c)<<16);s.rgba=r.premultiplyTint(p,u),s.styleId=l}}processHoles(t){for(let e=0;e<t.length;e++){const n=t[e],i=P[n.type];n.clearPath(),i.path(n,this.buildData),n.matrix&&this.transformPoints(n.points,n.matrix)}}calculateBounds(){const t=this._bounds,n=O;let i=e.Matrix.IDENTITY;this._bounds.clear(),n.clear();for(let s=0;s<this.graphicsData.length;s++){const r=this.graphicsData[s],a=r.shape,l=r.type,o=r.lineStyle,h=r.matrix||e.Matrix.IDENTITY;let c=0;if(o&&o.visible&&(c=o.width,l!==e.SHAPES.POLY||r.fillStyle.visible?c*=Math.max(0,o.alignment):c*=Math.max(o.alignment,1-o.alignment)),i!==h&&(n.isEmpty()||(t.addBoundsMatrix(n,i),n.clear()),i=h),l===e.SHAPES.RECT||l===e.SHAPES.RREC){const t=a;n.addFramePad(t.x,t.y,t.x+t.width,t.y+t.height,c,c)}else if(l===e.SHAPES.CIRC){const t=a;n.addFramePad(t.x,t.y,t.x,t.y,t.radius+c,t.radius+c)}else if(l===e.SHAPES.ELIP){const t=a;n.addFramePad(t.x,t.y,t.x,t.y,t.width+c,t.height+c)}else{const e=a;t.addVerticesMatrix(i,e.points,0,e.points.length,c,c)}}n.isEmpty()||t.addBoundsMatrix(n,i),t.pad(this.boundsPadding,this.boundsPadding)}transformPoints(t,e){for(let n=0;n<t.length/2;n++){const i=t[2*n],s=t[2*n+1];t[2*n]=e.a*i+e.c*s+e.tx,t[2*n+1]=e.b*i+e.d*s+e.ty}}}A.__initStatic();const D="#version 100\nprecision highp float;\nconst float FILL = 1.0;\nconst float BEVEL = 4.0;\nconst float MITER = 8.0;\nconst float ROUND = 12.0;\nconst float JOINT_CAP_BUTT = 16.0;\nconst float JOINT_CAP_SQUARE = 18.0;\nconst float JOINT_CAP_ROUND = 20.0;\n\nconst float FILL_EXPAND = 24.0;\n\nconst float CAP_BUTT = 1.0;\nconst float CAP_SQUARE = 2.0;\nconst float CAP_ROUND = 3.0;\nconst float CAP_BUTT2 = 4.0;\n\nconst float MITER_LIMIT = 10.0;\n\n// === geom ===\nattribute vec2 aPrev;\nattribute vec2 aPoint1;\nattribute vec2 aPoint2;\nattribute vec2 aNext;\nattribute float aVertexJoint;\nattribute float aTravel;\n\nuniform mat3 projectionMatrix;\nuniform mat3 translationMatrix;\nuniform vec4 tint;\n\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\n\nuniform float resolution;\nuniform float expand;\n\n// === style ===\nattribute float aStyleId;\nattribute vec4 aColor;\n\nvarying float vTextureId;\nvarying vec4 vColor;\nvarying vec2 vTextureCoord;\nvarying vec2 vTravel;\n\nuniform vec2 styleLine[%MAX_STYLES%];\nuniform vec3 styleMatrix[2 * %MAX_STYLES%];\nuniform float styleTextureId[%MAX_STYLES%];\nuniform vec2 samplerSize[%MAX_TEXTURES%];\n\nvec2 doBisect(vec2 norm, float len, vec2 norm2, float len2,\n    float dy, float inner) {\n    vec2 bisect = (norm + norm2) / 2.0;\n    bisect /= dot(norm, bisect);\n    vec2 shift = dy * bisect;\n    if (inner > 0.5) {\n        if (len < len2) {\n            if (abs(dy * (bisect.x * norm.y - bisect.y * norm.x)) > len) {\n                return dy * norm;\n            }\n        } else {\n            if (abs(dy * (bisect.x * norm2.y - bisect.y * norm2.x)) > len2) {\n                return dy * norm;\n            }\n        }\n    }\n    return dy * bisect;\n}\n\nvoid main(void){\n    vec2 pointA = (translationMatrix * vec3(aPoint1, 1.0)).xy;\n    vec2 pointB = (translationMatrix * vec3(aPoint2, 1.0)).xy;\n\n    vec2 xBasis = pointB - pointA;\n    float len = length(xBasis);\n    vec2 forward = xBasis / len;\n    vec2 norm = vec2(forward.y, -forward.x);\n\n    float type = floor(aVertexJoint / 16.0);\n    float vertexNum = aVertexJoint - type * 16.0;\n    float dx = 0.0, dy = 1.0;\n\n    float capType = floor(type / 32.0);\n    type -= capType * 32.0;\n\n    int styleId = int(aStyleId + 0.5);\n    float lineWidth = styleLine[styleId].x;\n    vTextureId = floor(styleTextureId[styleId] / 4.0);\n    float scaleMode = styleTextureId[styleId] - vTextureId * 4.0;\n    float avgScale = 1.0;\n    if (scaleMode > 2.5) {\n        avgScale = length(translationMatrix * vec3(1.0, 0.0, 0.0));\n    } else if (scaleMode > 1.5) {\n        avgScale = length(translationMatrix * vec3(0.0, 1.0, 0.0));\n    } else if (scaleMode > 0.5) {\n        vec2 avgDiag = (translationMatrix * vec3(1.0, 1.0, 0.0)).xy;\n        avgScale = sqrt(dot(avgDiag, avgDiag) * 0.5);\n    }\n    lineWidth *= 0.5 * avgScale;\n    float lineAlignment = 2.0 * styleLine[styleId].y - 1.0;\n    vTextureCoord = vec2(0.0);\n\n    vec2 pos;\n\n    if (capType == CAP_ROUND) {\n        vertexNum += 4.0;\n        type = JOINT_CAP_ROUND;\n        capType = 0.0;\n        lineAlignment = -lineAlignment;\n    }\n\n    vLine1 = vec4(0.0, 10.0, 1.0, 0.0);\n    vLine2 = vec4(0.0, 10.0, 1.0, 0.0);\n    vArc = vec4(0.0);\n    if (type == FILL) {\n        pos = pointA;\n        vType = 0.0;\n        vLine2 = vec4(-2.0, -2.0, -2.0, 0.0);\n        vec2 vTexturePixel;\n        vTexturePixel.x = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2]);\n        vTexturePixel.y = dot(vec3(aPoint1, 1.0), styleMatrix[styleId * 2 + 1]);\n        vTextureCoord = vTexturePixel / samplerSize[int(vTextureId)];\n    } else if (type >= FILL_EXPAND && type < FILL_EXPAND + 7.5) {\n        // expand vertices\n        float flags = type - FILL_EXPAND;\n        float flag3 = floor(flags / 4.0);\n        float flag2 = floor((flags - flag3 * 4.0) / 2.0);\n        float flag1 = flags - flag3 * 4.0 - flag2 * 2.0;\n\n        vec2 prev = (translationMatrix * vec3(aPrev, 1.0)).xy;\n\n        if (vertexNum < 0.5) {\n            pos = prev;\n        } else if (vertexNum < 1.5) {\n            pos = pointA;\n        } else {\n            pos = pointB;\n        }\n        float len2 = length(aNext);\n        vec2 bisect = (translationMatrix * vec3(aNext, 0.0)).xy;\n        if (len2 > 0.01) {\n            bisect = normalize(bisect) * len2;\n        }\n\n        vec2 n1 = normalize(vec2(pointA.y - prev.y, -(pointA.x - prev.x)));\n        vec2 n2 = normalize(vec2(pointB.y - pointA.y, -(pointB.x - pointA.x)));\n        vec2 n3 = normalize(vec2(prev.y - pointB.y, -(prev.x - pointB.x)));\n\n        if (n1.x * n2.y - n1.y * n2.x < 0.0) {\n            n1 = -n1;\n            n2 = -n2;\n            n3 = -n3;\n        }\n        pos += bisect * expand;\n\n        vLine1 = vec4(16.0, 16.0, 16.0, -1.0);\n        if (flag1 > 0.5) {\n            vLine1.x = -dot(pos - prev, n1);\n        }\n        if (flag2 > 0.5) {\n            vLine1.y = -dot(pos - pointA, n2);\n        }\n        if (flag3 > 0.5) {\n            vLine1.z = -dot(pos - pointB, n3);\n        }\n        vLine1.xyz *= resolution;\n        vType = 2.0;\n    } else if (type >= BEVEL) {\n        float dy = lineWidth + expand;\n        float shift = lineWidth * lineAlignment;\n        float inner = 0.0;\n        if (vertexNum >= 1.5) {\n            dy = -dy;\n            inner = 1.0;\n        }\n\n        vec2 base, next, xBasis2, bisect;\n        float flag = 0.0;\n        float side2 = 1.0;\n        if (vertexNum < 0.5 || vertexNum > 2.5 && vertexNum < 3.5) {\n            next = (translationMatrix * vec3(aPrev, 1.0)).xy;\n            base = pointA;\n            flag = type - floor(type / 2.0) * 2.0;\n            side2 = -1.0;\n        } else {\n            next = (translationMatrix * vec3(aNext, 1.0)).xy;\n            base = pointB;\n            if (type >= MITER && type < MITER + 3.5) {\n                flag = step(MITER + 1.5, type);\n                // check miter limit here?\n            }\n        }\n        xBasis2 = next - base;\n        float len2 = length(xBasis2);\n        vec2 norm2 = vec2(xBasis2.y, -xBasis2.x) / len2;\n        float D = norm.x * norm2.y - norm.y * norm2.x;\n        if (D < 0.0) {\n            inner = 1.0 - inner;\n        }\n\n        norm2 *= side2;\n\n        float collinear = step(0.0, dot(norm, norm2));\n\n        vType = 0.0;\n        float dy2 = -1000.0;\n\n        if (abs(D) < 0.01 && collinear < 0.5) {\n            if (type >= ROUND && type < ROUND + 1.5) {\n                type = JOINT_CAP_ROUND;\n            }\n            //TODO: BUTT here too\n        }\n\n        vLine1 = vec4(0.0, lineWidth, max(abs(norm.x), abs(norm.y)), min(abs(norm.x), abs(norm.y)));\n        vLine2 = vec4(0.0, lineWidth, max(abs(norm2.x), abs(norm2.y)), min(abs(norm2.x), abs(norm2.y)));\n\n        if (vertexNum < 3.5) {\n            if (abs(D) < 0.01 && collinear < 0.5) {\n                pos = (shift + dy) * norm;\n            } else {\n                if (flag < 0.5 && inner < 0.5) {\n                    pos = (shift + dy) * norm;\n                } else {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, inner);\n                }\n            }\n            vLine2.y = -1000.0;\n            if (capType >= CAP_BUTT && capType < CAP_ROUND) {\n                float extra = step(CAP_SQUARE, capType) * lineWidth;\n                vec2 back = -forward;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    pos += back * (expand + extra);\n                    dy2 = expand;\n                } else {\n                    dy2 = dot(pos + base - pointA, back) - extra;\n                }\n            }\n            if (type >= JOINT_CAP_BUTT && type < JOINT_CAP_SQUARE + 0.5) {\n                float extra = step(JOINT_CAP_SQUARE, type) * lineWidth;\n                if (vertexNum < 0.5 || vertexNum > 2.5) {\n                    vLine2.y = dot(pos + base - pointB, forward) - extra;\n                } else {\n                    pos += forward * (expand + extra);\n                    vLine2.y = expand;\n                    if (capType >= CAP_BUTT) {\n                        dy2 -= expand + extra;\n                    }\n                }\n            }\n        } else if (type >= JOINT_CAP_ROUND && type < JOINT_CAP_ROUND + 1.5) {\n            base += shift * norm;\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            vec2 d2 = abs(dy) * forward;\n            if (vertexNum < 4.5) {\n                dy = -dy;\n                pos = dy * norm;\n            } else if (vertexNum < 5.5) {\n                pos = dy * norm;\n            } else if (vertexNum < 6.5) {\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            } else {\n                dy = -dy;\n                pos = dy * norm + d2;\n                vArc.x = abs(dy);\n            }\n            vLine2 = vec4(0.0, lineWidth * 2.0 + 10.0, 1.0  , 0.0); // forget about line2 with type=3\n            vArc.y = dy;\n            vArc.z = 0.0;\n            vArc.w = lineWidth;\n            vType = 3.0;\n        } else if (abs(D) < 0.01 && collinear < 0.5) {\n            pos = dy * norm;\n        } else {\n            if (inner > 0.5) {\n                dy = -dy;\n                inner = 0.0;\n            }\n            float side = sign(dy);\n            vec2 norm3 = normalize(norm + norm2);\n\n            if (type >= MITER && type < MITER + 3.5) {\n                vec2 farVertex = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\n                if (length(farVertex) > abs(shift + dy) * MITER_LIMIT) {\n                    type = BEVEL;\n                }\n            }\n\n            if (vertexNum < 4.5) {\n                pos = doBisect(norm, len, norm2, len2, shift - dy, 1.0);\n            } else if (vertexNum < 5.5) {\n                pos = (shift + dy) * norm;\n            } else if (vertexNum > 7.5) {\n                pos = (shift + dy) * norm2;\n            } else {\n                if (type >= ROUND && type < ROUND + 1.5) {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0);\n                    float d2 = abs(shift + dy);\n                    if (length(pos) > abs(shift + dy) * 1.5) {\n                        if (vertexNum < 6.5) {\n                            pos.x = (shift + dy) * norm.x - d2 * norm.y;\n                            pos.y = (shift + dy) * norm.y + d2 * norm.x;\n                        } else {\n                            pos.x = (shift + dy) * norm2.x + d2 * norm2.y;\n                            pos.y = (shift + dy) * norm2.y - d2 * norm2.x;\n                        }\n                    }\n                } else if (type >= MITER && type < MITER + 3.5) {\n                    pos = doBisect(norm, len, norm2, len2, shift + dy, 0.0); //farVertex\n                } else if (type >= BEVEL && type < BEVEL + 1.5) {\n                    float d2 = side / resolution;\n                    if (vertexNum < 6.5) {\n                        pos = (shift + dy) * norm + d2 * norm3;\n                    } else {\n                        pos = (shift + dy) * norm2 + d2 * norm3;\n                    }\n                }\n            }\n\n            if (type >= ROUND && type < ROUND + 1.5) {\n                vArc.x = side * dot(pos, norm3);\n                vArc.y = pos.x * norm3.y - pos.y * norm3.x;\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift);\n                vArc.w = lineWidth + side * shift;\n                vType = 3.0;\n            } else if (type >= MITER && type < MITER + 3.5) {\n                vType = 1.0;\n            } else if (type >= BEVEL && type < BEVEL + 1.5) {\n                vType = 4.0;\n                vArc.z = dot(norm, norm3) * (lineWidth + side * shift) - side * dot(pos, norm3);\n            }\n\n            dy = side * (dot(pos, norm) - shift);\n            dy2 = side * (dot(pos, norm2) - shift);\n        }\n\n        pos += base;\n        vLine1.xy = vec2(dy, vLine1.y) * resolution;\n        vLine2.xy = vec2(dy2, vLine2.y) * resolution;\n        vArc = vArc * resolution;\n        vTravel = vec2(aTravel * avgScale + dot(pos - pointA, vec2(-norm.y, norm.x)), avgScale);\n    }\n\n    gl_Position = vec4((projectionMatrix * vec3(pos, 1.0)).xy, 0.0, 1.0);\n\n    vColor = aColor * tint;\n}",M="%PRECISION%\nvarying vec4 vColor;\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying vec2 vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\n\n%PIXEL_LINE%\n\nvoid main(void){\n    %PIXEL_COVERAGE%\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n",w=["\nfloat pixelLine(float x, float A, float B) {\n    return clamp(x + 0.5, 0.0, 1.0);\n}\n","\nfloat pixelLine(float x, float A, float B) {\n    float y = abs(x), s = sign(x);\n    if (y * 2.0 < A - B) {\n        return 0.5 + s * y / A;\n    }\n    y -= (A - B) * 0.5;\n    y = max(1.0 - y / B, 0.0);\n    return (1.0 + s * (1.0 - y * y)) * 0.5;\n    //return clamp(x + 0.5, 0.0, 1.0);\n}\n"];class C extends n.Shader{constructor(t,e=D,i=M,s={}){e=C.generateVertexSrc(t,e),i=C.generateFragmentSrc(t,i);const{maxStyles:r,maxTextures:a}=t,l=new Int32Array(a);for(let t=0;t<a;t++)l[t]=t;super(n.Program.from(e,i),Object.assign(s,{styleMatrix:new Float32Array(6*r),styleTextureId:new Float32Array(r),styleLine:new Float32Array(2*r),samplerSize:new Float32Array(2*a),uSamplers:l,tint:new Float32Array([1,1,1,1]),resolution:1,expand:1})),this.settings=t}static generateVertexSrc(t,e=D){const{maxStyles:n,maxTextures:i}=t;return e=e.replace(/%MAX_TEXTURES%/gi,`${i}`).replace(/%MAX_STYLES%/gi,`${n}`)}static generateFragmentSrc(t,e=M){const{maxTextures:n,pixelLine:i}=t;return e=e.replace(/%PRECISION%/gi,"#version 100\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n").replace(/%PIXEL_LINE%/gi,w[i]).replace(/%PIXEL_COVERAGE%/gi,"float alpha = 1.0;\nif (vType < 0.5) {\n    float left = pixelLine(-vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float right = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float near = vLine2.x - 0.5;\n    float far = min(vLine2.x + 0.5, 0.0);\n    float top = vLine2.y - 0.5;\n    float bottom = min(vLine2.y + 0.5, 0.0);\n    alpha = (right - left) * max(bottom - top, 0.0) * max(far - near, 0.0);\n} else if (vType < 1.5) {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    alpha = a2 * b2 - a1 * b1;\n} else if (vType < 2.5) {\n    alpha *= max(min(vLine1.x + 0.5, 1.0), 0.0);\n    alpha *= max(min(vLine1.y + 0.5, 1.0), 0.0);\n    alpha *= max(min(vLine1.z + 0.5, 1.0), 0.0);\n} else if (vType < 3.5) {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float alpha_miter = a2 * b2 - a1 * b1;\n    float alpha_plane = clamp(vArc.z - vArc.x + 0.5, 0.0, 1.0);\n    float d = length(vArc.xy);\n    float circle_hor = max(min(vArc.w, d + 0.5) - max(-vArc.w, d - 0.5), 0.0);\n    float circle_vert = min(vArc.w * 2.0, 1.0);\n    float alpha_circle = circle_hor * circle_vert;\n    alpha = min(alpha_miter, max(alpha_circle, alpha_plane));\n} else {\n    float a1 = pixelLine(- vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float a2 = pixelLine(vLine1.y - vLine1.x, vLine1.z, vLine1.w);\n    float b1 = pixelLine(- vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    float b2 = pixelLine(vLine2.y - vLine2.x, vLine2.z, vLine2.w);\n    alpha = a2 * b2 - a1 * b1;\n    alpha *= clamp(vArc.z + 0.5, 0.0, 1.0);\n}\n").replace(/%MAX_TEXTURES%/gi,`${n}`).replace(/%FOR_LOOP%/gi,this.generateSampleSrc(n))}static generateSampleSrc(t){let e="";e+="\n",e+="\n";for(let n=0;n<t;n++)n>0&&(e+="\nelse "),n<t-1&&(e+=`if(textureId < ${n}.5)`),e+="\n{",e+=`\n\ttexColor = texture2D(uSamplers[${n}], vTextureCoord);`,e+="\n}";return e+="\n",e+="\n",e}}const J={LINE_SCALE_MODE:t.LINE_SCALE_MODE.NORMAL,SHADER_MAX_STYLES:24,SHADER_MAX_TEXTURES:4,PIXEL_LINE:0},R=s.Graphics,{BezierUtils:B,QuadraticUtils:Y,ArcUtils:U}=s.graphicsUtils,F=new Float32Array(3),k={};class z extends a.Container{static get nextRoundedRectBehavior(){return R.nextRoundedRectBehavior}static set nextRoundedRectBehavior(t){R.nextRoundedRectBehavior=t}static __initStatic(){this._TEMP_POINT=new e.Point}get geometry(){return this._geometry}constructor(t=null){super(),this._geometry=t||new A,this._geometry.refCount++,this.shader=null,this.shaderSettings={maxStyles:J.SHADER_MAX_STYLES,maxTextures:J.SHADER_MAX_TEXTURES,pixelLine:J.PIXEL_LINE},this.state=n.State.for2d(),this._fillStyle=new u,this._lineStyle=new p,this._matrix=null,this._holeMode=!1,this.currentPath=null,this.batches=[],this.batchTint=-1,this.batchDirty=-1,this.vertexData=null,this.pluginName="smooth",this._transformID=-1,this.tint=16777215,this.blendMode=i.BLEND_MODES.NORMAL}clone(){return this.finishPoly(),new z(this._geometry)}set blendMode(t){this.state.blendMode=t}get blendMode(){return this.state.blendMode}get tint(){return this._tint}set tint(t){this._tint=t}get fill(){return this._fillStyle}get line(){return this._lineStyle}lineStyle(e=null,n=0,i=1,s=.5,r=J.LINE_SCALE_MODE){if("number"==typeof e)"boolean"==typeof r&&(r=r?t.LINE_SCALE_MODE.NONE:t.LINE_SCALE_MODE.NORMAL),e={width:e,color:n,alpha:i,alignment:s,scaleMode:r};else{const n=e.native;void 0!==n&&(e.scaleMode=n?t.LINE_SCALE_MODE.NONE:t.LINE_SCALE_MODE.NORMAL)}return this.lineTextureStyle(e)}lineTextureStyle(t){t=Object.assign({width:0,texture:n.Texture.WHITE,color:t&&t.texture?16777215:0,alpha:1,matrix:null,alignment:.5,native:!1,cap:s.LINE_CAP.BUTT,join:s.LINE_JOIN.MITER,miterLimit:10,shader:null,scaleMode:J.LINE_SCALE_MODE},t),this.currentPath&&this.startPoly();const e=t.width>0&&t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._lineStyle,{visible:e},t)):this._lineStyle.reset(),this}startPoly(){if(this.currentPath){const t=this.currentPath.points,n=this.currentPath.points.length;n>2&&(this.drawShape(this.currentPath),this.currentPath=new e.Polygon,this.currentPath.closeStroke=!1,this.currentPath.points.push(t[n-2],t[n-1]))}else this.currentPath=new e.Polygon,this.currentPath.closeStroke=!1}finishPoly(){this.currentPath&&(this.currentPath.points.length>2?(this.drawShape(this.currentPath),this.currentPath=null):this.currentPath.points.length=0)}moveTo(t,e){return this.startPoly(),this.currentPath.points[0]=t,this.currentPath.points[1]=e,this}lineTo(t,e){this.currentPath||this.moveTo(0,0);const n=this.currentPath.points,i=n[n.length-2],s=n[n.length-1];return i===t&&s===e||n.push(t,e),this}_initCurve(t=0,e=0){this.currentPath?0===this.currentPath.points.length&&(this.currentPath.points=[t,e]):this.moveTo(t,e)}quadraticCurveTo(t,e,n,i){this._initCurve();const s=this.currentPath.points;return 0===s.length&&this.moveTo(0,0),Y.curveTo(t,e,n,i,s),this}bezierCurveTo(t,e,n,i,s,r){return this._initCurve(),B.curveTo(t,e,n,i,s,r,this.currentPath.points),this}arcTo(t,e,n,i,s){this._initCurve(t,e);const r=this.currentPath.points,a=U.curveTo(t,e,n,i,s,r);if(a){const{cx:t,cy:e,radius:n,startAngle:i,endAngle:s,anticlockwise:r}=a;this.arc(t,e,n,i,s,r)}return this}arc(t,n,i,s,r,a=!1){if(s===r)return this;!a&&r<=s?r+=e.PI_2:a&&s<=r&&(s+=e.PI_2);if(0===r-s)return this;const l=t+Math.cos(s)*i,o=n+Math.sin(s)*i,h=this._geometry.closePointEps;let c=this.currentPath?this.currentPath.points:null;if(c){const t=Math.abs(c[c.length-2]-l),e=Math.abs(c[c.length-1]-o);t<h&&e<h||c.push(l,o)}else this.moveTo(l,o),c=this.currentPath.points;return U.arc(l,o,t,n,i,s,r,a,c),this}beginFill(t=0,e=1,i=!1){return this.beginTextureFill({texture:n.Texture.WHITE,color:t,alpha:e,smooth:i})}beginTextureFill(t){t=Object.assign({texture:n.Texture.WHITE,color:16777215,alpha:1,matrix:null,smooth:!1},t),this.currentPath&&this.startPoly();const e=t.alpha>0;return e?(t.matrix&&(t.matrix=t.matrix.clone(),t.matrix.invert()),Object.assign(this._fillStyle,{visible:e},t)):this._fillStyle.reset(),this}endFill(){return this.finishPoly(),this._fillStyle.reset(),this}drawRect(t,n,i,s){return this.drawShape(new e.Rectangle(t,n,i,s))}drawRoundedRect(t,n,i,s,r){return this.drawShape(new e.RoundedRectangle(t,n,i,s,r))}drawCircle(t,n,i){return this.drawShape(new e.Circle(t,n,i))}drawEllipse(t,n,i,s){return this.drawShape(new e.Ellipse(t,n,i,s))}drawPolygon(...t){let n,i=!0;const s=t[0];s.points?(i=s.closeStroke,n=s.points):n=Array.isArray(t[0])?t[0]:t;const r=new e.Polygon(n);return r.closeStroke=i,this.drawShape(r),this}drawShape(t){return this._holeMode?this._geometry.drawHole(t,this._matrix):this._geometry.drawShape(t,this._fillStyle.clone(),this._lineStyle.clone(),this._matrix),this}clear(){return this._geometry.clear(),this._lineStyle.reset(),this._fillStyle.reset(),this._boundsID++,this._matrix=null,this._holeMode=!1,this.currentPath=null,this}isFastRect(){const t=this._geometry.graphicsData;return!(1!==t.length||t[0].shape.type!==e.SHAPES.RECT||t[0].matrix||t[0].holes.length||t[0].lineStyle.visible&&t[0].lineStyle.width)}_renderCanvas(t){R.prototype._renderCanvas.call(this,t)}_render(t){this.finishPoly();const e=this._geometry,n=t.context.supports.uint32Indices;e.checkInstancing(t.geometry.hasInstance,n),e.updateBatches(this.shaderSettings),e.batchable?(this.batchDirty!==e.batchDirty&&this._populateBatches(),this._renderBatched(t)):(t.batch.flush(),this._renderDirect(t))}_populateBatches(){const t=this._geometry,e=this.blendMode,n=t.batches.length;this.batchTint=-1,this._transformID=-1,this.batchDirty=t.batchDirty,this.batches.length=n,this.vertexData=new Float32Array(t.points);for(let i=0;i<n;i++){const n=t.batches[i],s=n.style.color,a={vertexData:new Float32Array(this.vertexData.buffer,4*n.attribStart*2,2*n.attribSize),blendMode:e,_batchRGB:r.hex2rgb(s),_tintRGB:s,_texture:n.style.texture,alpha:n.style.alpha,worldAlpha:1};this.batches[i]=a}}_renderBatched(t){if(this.batches.length){t.batch.setObjectRenderer(t.plugins[this.pluginName]),this.calculateVertices(),this.calculateTints();for(let e=0,n=this.batches.length;e<n;e++){const n=this.batches[e];n.worldAlpha=this.worldAlpha*n.alpha,t.plugins[this.pluginName].render(n)}}}_renderDirect(t){const e=this._resolveDirectShader(t);let n=e;const s=this._geometry,r=this.tint,a=this.worldAlpha,l=n.uniforms,o=s.drawCalls;l.translationMatrix=this.transform.worldTransform,l.tint[0]=(r>>16&255)/255*a,l.tint[1]=(r>>8&255)/255*a,l.tint[2]=(255&r)/255*a,l.tint[3]=a,l.resolution=t.renderTexture.current?t.renderTexture.current.resolution:t.resolution;const h=t.projection.transform;if(h){const t=Math.sqrt(h.a*h.a+h.b*h.b);l.resolution*=t}l.expand=(t.options.antialias?2:1)/l.resolution,t.shader.bind(n),t.geometry.bind(s,n),t.state.set(this.state),n=null;for(let r=0,a=o.length;r<a;r++){const a=s.drawCalls[r],o=n!==a.shader;o&&(n=a.shader,n&&(n.uniforms.translationMatrix=this.transform.worldTransform,n.uniforms.tint&&(n.uniforms.tint[0]=l.tint[0],n.uniforms.tint[1]=l.tint[1],n.uniforms.tint[2]=l.tint[2],n.uniforms.tint[3]=l.tint[3])));const{texArray:h,styleArray:c,size:u,start:p}=a,d=h.count,f=n||e,y=f.uniforms.styleTextureId,_=f.uniforms.styleMatrix,T=f.uniforms.styleLine;for(let t=0;t<c.count;t++){y[t]=c.textureIds[t],T[2*t]=c.lines[2*t],T[2*t+1]=c.lines[2*t+1];const e=c.matrices[t];_[6*t]=e.a,_[6*t+1]=e.c,_[6*t+2]=e.tx,_[6*t+3]=e.b,_[6*t+4]=e.d,_[6*t+5]=e.ty}const x=f.uniforms.samplerSize;for(let t=0;t<d;t++)x[2*t]=h.elements[t].width,x[2*t+1]=h.elements[t].height;t.shader.bind(f),o&&t.geometry.bind(s);for(let e=0;e<d;e++)t.texture.bind(h.elements[e],e);t.geometry.draw(i.DRAW_MODES.TRIANGLES,u,p)}}_resolveDirectShader(t){let e=this.shader;const n=this.pluginName;return e||(k[n]||(k[n]=new C(this.shaderSettings)),e=k[n]),e}_calculateBounds(){this.finishPoly();const t=this._geometry;if(!t.graphicsData.length)return;const{minX:e,minY:n,maxX:i,maxY:s}=t.bounds;this._bounds.addFrame(this.transform,e,n,i,s)}containsPoint(t){return this.worldTransform.applyInverse(t,z._TEMP_POINT),this._geometry.containsPoint(z._TEMP_POINT)}calculateTints(){if(this.batchTint!==this.tint){this.batchTint=this.tint;const t=r.hex2rgb(this.tint,F);for(let e=0;e<this.batches.length;e++){const n=this.batches[e],i=n._batchRGB,s=(t[0]*i[0]*255<<16)+(t[1]*i[1]*255<<8)+(0|t[2]*i[2]*255);n._tintRGB=(s>>16)+(65280&s)+((255&s)<<16)}}}calculateVertices(){const t=this.transform._worldID;if(this._transformID===t)return;this._transformID=t;const e=this.transform.worldTransform,n=e.a,i=e.b,s=e.c,r=e.d,a=e.tx,l=e.ty,o=this._geometry.points,h=this.vertexData;let c=0;for(let t=0;t<o.length;t+=2){const e=o[t],u=o[t+1];h[c++]=n*e+s*u+a,h[c++]=r*u+i*e+l}}closePath(){const t=this.currentPath;return t&&(t.closeStroke=!0),this}setMatrix(t){return this._matrix=t,this}beginHole(){return this.finishPoly(),this._holeMode=!0,this}endHole(){return this.finishPoly(),this._holeMode=!1,this}destroy(t){this._geometry.refCount--,0===this._geometry.refCount&&this._geometry.dispose(),this._matrix=null,this.currentPath=null,this._lineStyle.destroy(),this._lineStyle=null,this._fillStyle.destroy(),this._fillStyle=null,this._geometry=null,this.shader=null,this.vertexData=null,this.batches.length=0,this.batches=null,super.destroy(t)}}z.__initStatic();t.BATCH_POOL=b,t.BatchDrawCall=h,t.BatchPart=c,t.BatchStyleArray=o,t.BuildData=d,t.CircleBuilder=T,t.DRAW_CALL_POOL=L,t.DashLineShader=class extends C{constructor(t){super({maxStyles:16,maxTextures:1,pixelLine:1},void 0,"%PRECISION%\nvarying vec4 vColor;\nvarying vec4 vLine1;\nvarying vec4 vLine2;\nvarying vec4 vArc;\nvarying float vType;\nvarying float vTextureId;\nvarying vec2 vTextureCoord;\nvarying vec2 vTravel;\nuniform sampler2D uSamplers[%MAX_TEXTURES%];\nuniform float dash;\nuniform float gap;\n\n%PIXEL_LINE%\n\nvoid main(void){\n    %PIXEL_COVERAGE%\n\n    float d = dash * vTravel.y;\n    if (d > 0.0) {\n        float g = gap * vTravel.y;\n        if (g > 0.0) {\n            float t = mod(vTravel.x, d + g);\n            alpha *= mix(\n                min(0.5 * d + 0.5 - abs(t - 0.5 * d), 1.0),\n                max(abs(t - 0.5 * g - d) - 0.5 * g + 0.5, 0.0),\n                step(d, t)\n            );\n        }\n    } else {\n        alpha = 0.0;\n    }\n\n    vec4 texColor;\n    float textureId = floor(vTextureId+0.5);\n    %FOR_LOOP%\n\n    gl_FragColor = vColor * texColor * alpha;\n}\n",t||{dash:8,gap:5})}},t.FILL_COMMANDS=P,t.FillStyle=u,t.LineStyle=p,t.PolyBuilder=m,t.RectangleBuilder=g,t.RoundedRectangleBuilder=N,t.SegmentPacker=f,t.SmoothGraphics=z,t.SmoothGraphicsData=_,t.SmoothGraphicsGeometry=A,t.SmoothGraphicsShader=C,t.matrixEquals=l,t.settings=J,Object.defineProperty(t,"__esModule",{value:!0})})),"undefined"!=typeof _pixi_graphics_smooth&&Object.assign(this.PIXI.smooth,_pixi_graphics_smooth);
//# sourceMappingURL=pixi-graphics-smooth.umd.min.js.map
